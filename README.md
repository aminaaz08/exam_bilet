# exam_bilet

**Билет 1. «Программа на языке C++»**
---
Язык C++ — это компилируемый язык программирования общего назначения, сочетающий низкоуровневые возможности управления ресурсами с высокоуровневыми абстракциями объектно-ориентированного и обобщённого программирования. Программа на C++ состоит из одного или нескольких **исходных файлов** (обычно с расширением `.cpp`) и **заголовочных файлов** (`.h` или `.hpp`). Рассмотрим подробнее все аспекты, связанные с организацией, сборкой и выполнением такой программы.

---

#### **1. Содержимое файлов `.cpp` и `.h`**

- **Заголовочные файлы** (`.h`, `.hpp`) содержат **объявления**:  
  - прототипы функций,  
  - объявления классов,  
  - макросы,  
  - внешние переменные (`extern`),  
  - шаблоны (в том числе функций и классов).  
  Они служат своего рода «интерфейсом» модуля — то, что другие части программы должны знать о данном модуле, чтобы его использовать.

- **Исходные файлы** (`.cpp`) содержат **определения**:  
  - тела функций,  
  - реализации методов классов,  
  - определения глобальных переменных.  
  Это — исполняемая часть кода, которая компилируется в объектный файл.

---

#### **2. Зачем разделять код на `.h` и `.cpp`?**

Разделение на заголовочные и исходные файлы решает несколько важных задач:

- **Повторное использование**: один заголовочный файл может подключаться во множество `.cpp`-файлов, обеспечивая согласованность интерфейса.
- **Компиляция по частям**: при изменении реализации (в `.cpp`) не нужно перекомпилировать все зависимости — только сам файл. Это ускоряет сборку.
- **Сокрытие реализации**: пользователь модуля видит только интерфейс (`.h`), но не детали реализации (`.cpp`).
- **Избежание множественного определения**: если бы всё было в `.cpp`, подключение одного файла в другой привело бы к дублированию определений при линковке.

---

#### **3. Структура программы**

##### **Точка входа**
Точка входа в любую программу на C++ — это функция `main()`. Она вызывается операционной системой при запуске программы. Существует два стандартных варианта её объявления:

```cpp
int main();
int main(int argc, char* argv[]);
```

Первый — без аргументов командной строки, второй — с ними.

##### **Назначение `return` в `main`**
Оператор `return` в функции `main` возвращает **код завершения программы** в операционную систему:
- `return 0;` или `return EXIT_SUCCESS;` — успешное завершение,
- ненулевое значение (например, `return 1;` или `return EXIT_FAILURE;`) — ошибка.

Если `main` не содержит явного `return`, компилятор автоматически добавляет `return 0;`.

---

#### **4. Структурные элементы программы**

- **Директивы препроцессора**: команды, обрабатываемые до компиляции (например, `#include`, `#define`, `#ifdef`).
- **Комментарии**:
  - Однострочные: `// комментарий`
  - Многострочные: `/* комментарий */`
  - Также возможны документирующие комментарии (Doxygen): `///`, `/** ... */`
- **Подключение стороннего кода**: осуществляется с помощью директивы `#include <...>` (для системных заголовков) или `#include "..."` (для пользовательских).

---

#### **5. Проблемы циклического и повторного подключения заголовков**

Если заголовочный файл подключается несколько раз (прямо или косвенно), возникает ошибка **множественного определения**. Если файлы включают друг друга циклически (`A.h → B.h → A.h`), компилятор зацикливается.

**Способы решения**:

- **Include guards** (защитные директивы):
  ```cpp
  #ifndef MY_HEADER_H
  #define MY_HEADER_H
  // содержимое
  #endif
  ```
- **`#pragma once`** — нестандартная, но широко поддерживаемая директива, обеспечивающая однократное включение файла.

Оба подхода предотвращают повторную обработку содержимого заголовка.

---

#### **6. Подключение статических и динамических библиотек**

- **Статические библиотеки** (`.a` в Linux, `.lib` в Windows) — код библиотеки **копируется** в исполняемый файл на этапе линковки. Преимущества: автономность; недостатки: увеличение размера, невозможность обновления без пересборки.
- **Динамические библиотеки** (`.so` в Linux, `.dll` в Windows) — подгружаются **во время выполнения**. Преимущества: экономия памяти, возможность обновления; недостатки: зависимость от наличия библиотеки в системе.

Подключение:
- На этапе компиляции указываются флаги (`-l` для линковки, `-L` для путей).
- В коде используется `#include` для заголовков библиотеки.

---

#### **7. Этапы сборки программы**

Сборка C++-программы проходит в **четыре основных этапа**:

1. **Препроцессинг**: обработка директив (`#include`, `#define` и т.д.). Результат — расширенный исходный код.
2. **Компиляция**: перевод каждого `.cpp`-файла в **объектный файл** (`.o` или `.obj`), содержащий машинный код, но без разрешения внешних ссылок.
3. **Оптимизация**: выполняется компилятором (на этапе компиляции) или линкером (link-time optimization). Может включать инлайнинг, удаление мёртвого кода, переупорядочивание и т.д.
4. **Компоновка (линковка)**: объединение объектных файлов и библиотек в единый исполняемый файл. Линкер разрешает внешние ссылки (например, вызовы функций из других модулей).

**Основные компиляторы C++**:
- **GCC** (GNU Compiler Collection) — открытый, кроссплатформенный.
- **Clang** — современный, с отличными диагностическими сообщениями.
- **MSVC** (Microsoft Visual C++) — стандарт для Windows в экосистеме Microsoft.

---

#### **8. Артефакты сборки**

- **Исполняемый файл** (`.exe` в Windows, без расширения или с `.out` в Unix-системах) — готовая программа, которую можно запустить.
- **Статическая библиотека** — архив объектных файлов (`.a` / `.lib`), подключаемый на этапе линковки.
- **Динамическая библиотека** — отдельный файл (`.so` / `.dll`), загружаемый ОС при запуске или во время выполнения.

---

#### **9. Запуск программы**

- **Без IDE**: через командную строку:  
  ```bash
  ./my_program arg1 arg2
  ```
- **Поиск динамических библиотек**:
  - В Linux: переменная окружения `LD_LIBRARY_PATH`, системные каталоги (`/usr/lib`, `/lib`).
  - В Windows: текущая директория, системные пути (`PATH`), каталог программы.
- **Аргументы командной строки** передаются в `main` через параметры:
  ```cpp
  int main(int argc, char* argv[])
  ```
  где `argc` — количество аргументов (включая имя программы), `argv` — массив строк с аргументами.

---

#### **10. Размещение программы в памяти**

При запуске программа загружается в **виртуальное адресное пространство процесса**, которое делится на сегменты:

- **Текст (code segment)** — машинные инструкции (только для чтения).
- **Данные**:
  - Инициализированные глобальные/статические переменные (`.data`),
  - Неинициализированные (`.bss`).
- **Стек (stack)** — автоматически управляемая область памяти для локальных переменных и вызовов функций. Растёт «вниз». Ограничен по размеру (обычно несколько МБ).
- **Куча (heap)** — динамически выделяемая память (через `new`/`malloc`). Управляется программистом. Может быть ограничена только объёмом виртуальной памяти.

**Доступный объём памяти зависит от разрядности**:
- **32-битная система**: максимум ~4 ГБ виртуального адресного пространства (часто ~2–3 ГБ для пользователя).
- **64-битная система**: теоретически до 2⁶⁴ байт (~16 ЭБ), на практике ограничено ОС (например, Windows использует 48 бит → ~256 ТБ).

---

### **Заключение**

Таким образом, программа на C++ — это сложная система, включающая строгую модульную структуру, многоэтапную сборку и чёткое распределение ресурсов в памяти. Понимание этих механизмов позволяет писать эффективный, надёжный и поддерживаемый код, а также успешно отлаживать и оптимизировать приложения.

---

 **Билет 2. «Переменные и константы в языке C++»**
---

Переменная в языке C++ — это именованная область памяти, предназначенная для хранения данных определённого типа. Константа — это переменная, значение которой **нельзя изменить** после инициализации. В C++ работа с переменными и константами строго регламентирована и включает правила их создания, именования, размещения в памяти, времени жизни и способов доступа. Рассмотрим все аспекты подробно.

---

### **1. Создание переменной**

Создание переменной в C++ происходит в два этапа:
- **Объявление** — сообщает компилятору имя и тип переменной.
- **Определение** — выделяет память под переменную (может совпадать с объявлением).

Пример:
```cpp
int x;          // объявление + определение
extern int y;   // только объявление
```

---

### **2. Идентификатор переменной**

Идентификатор — это имя переменной.

#### **Правила именования**
- Может содержать буквы латинского алфавита (`a–z`, `A–Z`), цифры (`0–9`) и символ подчёркивания (`_`).
- **Не может начинаться с цифры**.
- **Не может совпадать с ключевыми словами** (`int`, `return`, `class` и т.д.).
- Рекомендуется использовать осмысленные имена (`counter`, `userName`).

#### **Регистр**
- C++ **чувствителен к регистру**: `count`, `Count`, `COUNT` — разные идентификаторы.

---

### **3. Объявление переменной**

Структура объявления:
```cpp
[спецификаторы] тип имя [= инициализатор];
```

Примеры:
```cpp
int a;
double price = 199.99;
const char* name = "Alice";
```

Объявление может включать:
- спецификаторы (`const`, `static`, `extern`, `mutable`),
- тип (`int`, `MyClass`, `auto`),
- инициализатор (опционально).

---

### **4. Ключевые слова**

#### **`const`**
Указывает, что значение переменной **не может быть изменено** после инициализации:
```cpp
const int MAX = 100;
```

#### **`constexpr`**
Гарантирует, что значение вычисляется **на этапе компиляции**:
```cpp
constexpr int square(int x) { return x * x; }
constexpr int val = square(5); // 25 — известно на этапе компиляции
```

#### **`auto`**
Позволяет компилятору **вывести тип** из инициализатора:
```cpp
auto x = 42;        // int
auto y = 3.14;      // double
```

#### **`decltype`**
Возвращает **тип выражения**:
```cpp
int a = 5;
decltype(a) b = 10; // b имеет тип int
```

#### **`extern`**
Указывает, что переменная **определена в другом файле** (объявление без выделения памяти):
```cpp
// file1.cpp
int global_var = 42;

// file2.cpp
extern int global_var; // используем, но не определяем здесь
```

#### **`static`**
- **Для глобальной переменной**: ограничивает видимость текущим файлом (внутреннее связывание).
- **Для локальной переменной**: сохраняет значение между вызовами функции; инициализируется один раз.

```cpp
void func() {
    static int count = 0; // живёт всё время программы
    ++count;
}
```

#### **`mutable`**
Позволяет изменять член класса даже внутри `const`-метода:
```cpp
class Counter {
    mutable int cache;
public:
    void update() const { cache = 42; } // допустимо благодаря mutable
};
```

---

### **5. Определение и ODR**

#### **One Definition Rule (ODR)**
Правило гласит: **любая переменная, функция или класс может иметь ровно одно определение в программе** (если используется). Нарушение → ошибка линковки.

#### **Отличие объявления от определения**
- **Объявление** — сообщает компилятору о существовании сущности (без выделения памяти).
- **Определение** — выделяет память и, возможно, инициализирует.

Пример:
```cpp
extern int x; // объявление
int x = 10;   // определение
```

---

### **6. Инициализация**

#### **Неинициализированные переменные**
- **Локальные** (в функции): содержат **мусор** (неопределённое значение).
- **Глобальные/статические**: автоматически инициализируются **нулем** (zero-initialization).

#### **Значения по умолчанию**
- **Простые типы** (`int`, `double`, указатели):  
  - глобальные → `0`, `0.0`, `nullptr`  
  - локальные → неопределённые  
- **Объекты классов**: вызывается **конструктор по умолчанию**, если он существует.

#### **Способы инициализации (≥3)**
1. **Копирующая инициализация**: `int a = 5;`
2. **Прямая инициализация**: `int a(5);`
3. **Униформная (списочная) инициализация** (C++11): `int a{5};` или `int a = {5};`
4. **Инициализация через `auto`**: `auto x = 10;`
5. **Агрегатная инициализация** (для структур/массивов): `Point p{1, 2};`

#### **Назначение инициализации**
- Гарантирует предсказуемое начальное состояние.
- Предотвращает ошибки, связанные с использованием мусора.

#### **Когда можно не инициализировать?**
- Если переменная будет **гарантированно проинициализирована до первого использования** (например, в `if-else`).
- Однако **лучшая практика — всегда инициализировать**.

---

### **7. Способы выделения памяти**

#### **Стек**
- Автоматическая память.
- Создаётся при входе в блок, уничтожается при выходе.
- Пример:
  ```cpp
  void func() {
      int x = 10; // на стеке
  }
  ```

#### **Куча**
- Динамическая память.
- Выделяется вручную через `new`, освобождается через `delete`.
- Пример:
  ```cpp
  int* p = new int(42); // в куче
  delete p;             // обязательно освободить!
  ```
  В современном C++ рекомендуется использовать **умные указатели** (`std::unique_ptr`, `std::shared_ptr`).

---

### **8. Использование переменной**

Доступ к переменной осуществляется:
- По **имени** (если в области видимости).
- Через **указатель**: `*ptr`
- Через **ссылку**: `ref`

Пример:
```cpp
int x = 5;
int& r = x;     // ссылка
int* p = &x;    // указатель
```

---

### **9. Связывание и область видимости**

#### **Статическое (лексическое) связывание**
- Имя переменной связывается с адресом **на этапе компиляции**.
- Это стандартный механизм в C++.

#### **Динамическое связывание**
- В C++ **не применяется к переменным** (только к виртуальным функциям).
- Переменные всегда связываются статически.

#### **Если переменная определена в другом `.cpp` файле**
- Используется `extern` для объявления.
- Линкер связывает ссылки на этапе сборки.

#### **Область видимости (scope)**
- **Локальная**: внутри блока `{}`.
- **Глобальная**: вне всех функций.
- **Пространство имён**: `namespace N { int x; }`
- **Классовая**: члены класса.

---

### **10. Время жизни и уничтожение**

#### **Автоматические переменные (на стеке)**
- Живут **до конца блока**, в котором объявлены.
- Уничтожаются **автоматически** (деструктор вызывается, если есть).

#### **Динамические переменные (в куче)**
- Живут **до явного вызова `delete`**.
- Если не удалить — **утечка памяти**.

#### **Значение после уничтожения**
- После уничтожения переменной её память **освобождается**.
- Доступ к ней (через «висячий» указатель) — **неопределённое поведение (UB)**.
- Значение **недействительно**, даже если байты ещё не перезаписаны.

---

### **Заключение**

Таким образом, переменные и константы в C++ — это фундаментальные элементы управления данными, требующие глубокого понимания их жизненного цикла, размещения в памяти, правил именования и инициализации. Современный C++ предоставляет мощные инструменты (`const`, `constexpr`, `auto`, умные указатели), позволяющие писать безопасный, эффективный и читаемый код. Владение этими концепциями критически важно для успешной разработки и сдачи экзаменов.

---

