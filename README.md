# exam_bilet

**Билет 1. «Программа на языке C++»**
---
Язык C++ — это компилируемый язык программирования общего назначения, сочетающий низкоуровневые возможности управления ресурсами с высокоуровневыми абстракциями объектно-ориентированного и обобщённого программирования. Программа на C++ состоит из одного или нескольких **исходных файлов** (обычно с расширением `.cpp`) и **заголовочных файлов** (`.h` или `.hpp`). Рассмотрим подробнее все аспекты, связанные с организацией, сборкой и выполнением такой программы.

---

#### **1. Содержимое файлов `.cpp` и `.h`**

- **Заголовочные файлы** (`.h`, `.hpp`) содержат **объявления**:  
  - прототипы функций,  
  - объявления классов,  
  - макросы,  
  - внешние переменные (`extern`),  
  - шаблоны (в том числе функций и классов).  
  Они служат своего рода «интерфейсом» модуля — то, что другие части программы должны знать о данном модуле, чтобы его использовать.

- **Исходные файлы** (`.cpp`) содержат **определения**:  
  - тела функций,  
  - реализации методов классов,  
  - определения глобальных переменных.  
  Это — исполняемая часть кода, которая компилируется в объектный файл.

---

#### **2. Зачем разделять код на `.h` и `.cpp`?**

Разделение на заголовочные и исходные файлы решает несколько важных задач:

- **Повторное использование**: один заголовочный файл может подключаться во множество `.cpp`-файлов, обеспечивая согласованность интерфейса.
- **Компиляция по частям**: при изменении реализации (в `.cpp`) не нужно перекомпилировать все зависимости — только сам файл. Это ускоряет сборку.
- **Сокрытие реализации**: пользователь модуля видит только интерфейс (`.h`), но не детали реализации (`.cpp`).
- **Избежание множественного определения**: если бы всё было в `.cpp`, подключение одного файла в другой привело бы к дублированию определений при линковке.

---

#### **3. Структура программы**

##### **Точка входа**
Точка входа в любую программу на C++ — это функция `main()`. Она вызывается операционной системой при запуске программы. Существует два стандартных варианта её объявления:

```cpp
int main();
int main(int argc, char* argv[]);
```

Первый — без аргументов командной строки, второй — с ними.

##### **Назначение `return` в `main`**
Оператор `return` в функции `main` возвращает **код завершения программы** в операционную систему:
- `return 0;` или `return EXIT_SUCCESS;` — успешное завершение,
- ненулевое значение (например, `return 1;` или `return EXIT_FAILURE;`) — ошибка.

Если `main` не содержит явного `return`, компилятор автоматически добавляет `return 0;`.

---

#### **4. Структурные элементы программы**

- **Директивы препроцессора**: команды, обрабатываемые до компиляции (например, `#include`, `#define`, `#ifdef`).
- **Комментарии**:
  - Однострочные: `// комментарий`
  - Многострочные: `/* комментарий */`
  - Также возможны документирующие комментарии (Doxygen): `///`, `/** ... */`
- **Подключение стороннего кода**: осуществляется с помощью директивы `#include <...>` (для системных заголовков) или `#include "..."` (для пользовательских).

---

#### **5. Проблемы циклического и повторного подключения заголовков**

Если заголовочный файл подключается несколько раз (прямо или косвенно), возникает ошибка **множественного определения**. Если файлы включают друг друга циклически (`A.h → B.h → A.h`), компилятор зацикливается.

**Способы решения**:

- **Include guards** (защитные директивы):
  ```cpp
  #ifndef MY_HEADER_H
  #define MY_HEADER_H
  // содержимое
  #endif
  ```
- **`#pragma once`** — нестандартная, но широко поддерживаемая директива, обеспечивающая однократное включение файла.

Оба подхода предотвращают повторную обработку содержимого заголовка.

---

#### **6. Подключение статических и динамических библиотек**

- **Статические библиотеки** (`.a` в Linux, `.lib` в Windows) — код библиотеки **копируется** в исполняемый файл на этапе линковки. Преимущества: автономность; недостатки: увеличение размера, невозможность обновления без пересборки.
- **Динамические библиотеки** (`.so` в Linux, `.dll` в Windows) — подгружаются **во время выполнения**. Преимущества: экономия памяти, возможность обновления; недостатки: зависимость от наличия библиотеки в системе.

Подключение:
- На этапе компиляции указываются флаги (`-l` для линковки, `-L` для путей).
- В коде используется `#include` для заголовков библиотеки.

---

#### **7. Этапы сборки программы**

Сборка C++-программы проходит в **четыре основных этапа**:

1. **Препроцессинг**: обработка директив (`#include`, `#define` и т.д.). Результат — расширенный исходный код.
2. **Компиляция**: перевод каждого `.cpp`-файла в **объектный файл** (`.o` или `.obj`), содержащий машинный код, но без разрешения внешних ссылок.
3. **Оптимизация**: выполняется компилятором (на этапе компиляции) или линкером (link-time optimization). Может включать инлайнинг, удаление мёртвого кода, переупорядочивание и т.д.
4. **Компоновка (линковка)**: объединение объектных файлов и библиотек в единый исполняемый файл. Линкер разрешает внешние ссылки (например, вызовы функций из других модулей).

**Основные компиляторы C++**:
- **GCC** (GNU Compiler Collection) — открытый, кроссплатформенный.
- **Clang** — современный, с отличными диагностическими сообщениями.
- **MSVC** (Microsoft Visual C++) — стандарт для Windows в экосистеме Microsoft.

---

#### **8. Артефакты сборки**

- **Исполняемый файл** (`.exe` в Windows, без расширения или с `.out` в Unix-системах) — готовая программа, которую можно запустить.
- **Статическая библиотека** — архив объектных файлов (`.a` / `.lib`), подключаемый на этапе линковки.
- **Динамическая библиотека** — отдельный файл (`.so` / `.dll`), загружаемый ОС при запуске или во время выполнения.

---

#### **9. Запуск программы**

- **Без IDE**: через командную строку:  
  ```bash
  ./my_program arg1 arg2
  ```
- **Поиск динамических библиотек**:
  - В Linux: переменная окружения `LD_LIBRARY_PATH`, системные каталоги (`/usr/lib`, `/lib`).
  - В Windows: текущая директория, системные пути (`PATH`), каталог программы.
- **Аргументы командной строки** передаются в `main` через параметры:
  ```cpp
  int main(int argc, char* argv[])
  ```
  где `argc` — количество аргументов (включая имя программы), `argv` — массив строк с аргументами.

---

#### **10. Размещение программы в памяти**

При запуске программа загружается в **виртуальное адресное пространство процесса**, которое делится на сегменты:

- **Текст (code segment)** — машинные инструкции (только для чтения).
- **Данные**:
  - Инициализированные глобальные/статические переменные (`.data`),
  - Неинициализированные (`.bss`).
- **Стек (stack)** — автоматически управляемая область памяти для локальных переменных и вызовов функций. Растёт «вниз». Ограничен по размеру (обычно несколько МБ).
- **Куча (heap)** — динамически выделяемая память (через `new`/`malloc`). Управляется программистом. Может быть ограничена только объёмом виртуальной памяти.

**Доступный объём памяти зависит от разрядности**:
- **32-битная система**: максимум ~4 ГБ виртуального адресного пространства (часто ~2–3 ГБ для пользователя).
- **64-битная система**: теоретически до 2⁶⁴ байт (~16 ЭБ), на практике ограничено ОС (например, Windows использует 48 бит → ~256 ТБ).

---

### **Заключение**

Таким образом, программа на C++ — это сложная система, включающая строгую модульную структуру, многоэтапную сборку и чёткое распределение ресурсов в памяти. Понимание этих механизмов позволяет писать эффективный, надёжный и поддерживаемый код, а также успешно отлаживать и оптимизировать приложения.

---

 **Билет 2. «Переменные и константы в языке C++»**
---

Переменная в языке C++ — это именованная область памяти, предназначенная для хранения данных определённого типа. Константа — это переменная, значение которой **нельзя изменить** после инициализации. В C++ работа с переменными и константами строго регламентирована и включает правила их создания, именования, размещения в памяти, времени жизни и способов доступа. Рассмотрим все аспекты подробно.

---

### **1. Создание переменной**

Создание переменной в C++ происходит в два этапа:
- **Объявление** — сообщает компилятору имя и тип переменной.
- **Определение** — выделяет память под переменную (может совпадать с объявлением).

Пример:
```cpp
int x;          // объявление + определение
extern int y;   // только объявление
```

---

### **2. Идентификатор переменной**

Идентификатор — это имя переменной.

#### **Правила именования**
- Может содержать буквы латинского алфавита (`a–z`, `A–Z`), цифры (`0–9`) и символ подчёркивания (`_`).
- **Не может начинаться с цифры**.
- **Не может совпадать с ключевыми словами** (`int`, `return`, `class` и т.д.).
- Рекомендуется использовать осмысленные имена (`counter`, `userName`).

#### **Регистр**
- C++ **чувствителен к регистру**: `count`, `Count`, `COUNT` — разные идентификаторы.

---

### **3. Объявление переменной**

Структура объявления:
```cpp
[спецификаторы] тип имя [= инициализатор];
```

Примеры:
```cpp
int a;
double price = 199.99;
const char* name = "Alice";
```

Объявление может включать:
- спецификаторы (`const`, `static`, `extern`, `mutable`),
- тип (`int`, `MyClass`, `auto`),
- инициализатор (опционально).

---

### **4. Ключевые слова**

#### **`const`**
Указывает, что значение переменной **не может быть изменено** после инициализации:
```cpp
const int MAX = 100;
```

#### **`constexpr`**
Гарантирует, что значение вычисляется **на этапе компиляции**:
```cpp
constexpr int square(int x) { return x * x; }
constexpr int val = square(5); // 25 — известно на этапе компиляции
```

#### **`auto`**
Позволяет компилятору **вывести тип** из инициализатора:
```cpp
auto x = 42;        // int
auto y = 3.14;      // double
```

#### **`decltype`**
Возвращает **тип выражения**:
```cpp
int a = 5;
decltype(a) b = 10; // b имеет тип int
```

#### **`extern`**
Указывает, что переменная **определена в другом файле** (объявление без выделения памяти):
```cpp
// file1.cpp
int global_var = 42;

// file2.cpp
extern int global_var; // используем, но не определяем здесь
```

#### **`static`**
- **Для глобальной переменной**: ограничивает видимость текущим файлом (внутреннее связывание).
- **Для локальной переменной**: сохраняет значение между вызовами функции; инициализируется один раз.

```cpp
void func() {
    static int count = 0; // живёт всё время программы
    ++count;
}
```

#### **`mutable`**
Позволяет изменять член класса даже внутри `const`-метода:
```cpp
class Counter {
    mutable int cache;
public:
    void update() const { cache = 42; } // допустимо благодаря mutable
};
```

---

### **5. Определение и ODR**

#### **One Definition Rule (ODR)**
Правило гласит: **любая переменная, функция или класс может иметь ровно одно определение в программе** (если используется). Нарушение → ошибка линковки.

#### **Отличие объявления от определения**
- **Объявление** — сообщает компилятору о существовании сущности (без выделения памяти).
- **Определение** — выделяет память и, возможно, инициализирует.

Пример:
```cpp
extern int x; // объявление
int x = 10;   // определение
```

---

### **6. Инициализация**

#### **Неинициализированные переменные**
- **Локальные** (в функции): содержат **мусор** (неопределённое значение).
- **Глобальные/статические**: автоматически инициализируются **нулем** (zero-initialization).

#### **Значения по умолчанию**
- **Простые типы** (`int`, `double`, указатели):  
  - глобальные → `0`, `0.0`, `nullptr`  
  - локальные → неопределённые  
- **Объекты классов**: вызывается **конструктор по умолчанию**, если он существует.

#### **Способы инициализации (≥3)**
1. **Копирующая инициализация**: `int a = 5;`
2. **Прямая инициализация**: `int a(5);`
3. **Униформная (списочная) инициализация** (C++11): `int a{5};` или `int a = {5};`
4. **Инициализация через `auto`**: `auto x = 10;`
5. **Агрегатная инициализация** (для структур/массивов): `Point p{1, 2};`

#### **Назначение инициализации**
- Гарантирует предсказуемое начальное состояние.
- Предотвращает ошибки, связанные с использованием мусора.

#### **Когда можно не инициализировать?**
- Если переменная будет **гарантированно проинициализирована до первого использования** (например, в `if-else`).
- Однако **лучшая практика — всегда инициализировать**.

---

### **7. Способы выделения памяти**

#### **Стек**
- Автоматическая память.
- Создаётся при входе в блок, уничтожается при выходе.
- Пример:
  ```cpp
  void func() {
      int x = 10; // на стеке
  }
  ```

#### **Куча**
- Динамическая память.
- Выделяется вручную через `new`, освобождается через `delete`.
- Пример:
  ```cpp
  int* p = new int(42); // в куче
  delete p;             // обязательно освободить!
  ```
  В современном C++ рекомендуется использовать **умные указатели** (`std::unique_ptr`, `std::shared_ptr`).

---

### **8. Использование переменной**

Доступ к переменной осуществляется:
- По **имени** (если в области видимости).
- Через **указатель**: `*ptr`
- Через **ссылку**: `ref`

Пример:
```cpp
int x = 5;
int& r = x;     // ссылка
int* p = &x;    // указатель
```

---

### **9. Связывание и область видимости**

#### **Статическое (лексическое) связывание**
- Имя переменной связывается с адресом **на этапе компиляции**.
- Это стандартный механизм в C++.

#### **Динамическое связывание**
- В C++ **не применяется к переменным** (только к виртуальным функциям).
- Переменные всегда связываются статически.

#### **Если переменная определена в другом `.cpp` файле**
- Используется `extern` для объявления.
- Линкер связывает ссылки на этапе сборки.

#### **Область видимости (scope)**
- **Локальная**: внутри блока `{}`.
- **Глобальная**: вне всех функций.
- **Пространство имён**: `namespace N { int x; }`
- **Классовая**: члены класса.

---

### **10. Время жизни и уничтожение**

#### **Автоматические переменные (на стеке)**
- Живут **до конца блока**, в котором объявлены.
- Уничтожаются **автоматически** (деструктор вызывается, если есть).

#### **Динамические переменные (в куче)**
- Живут **до явного вызова `delete`**.
- Если не удалить — **утечка памяти**.

#### **Значение после уничтожения**
- После уничтожения переменной её память **освобождается**.
- Доступ к ней (через «висячий» указатель) — **неопределённое поведение (UB)**.
- Значение **недействительно**, даже если байты ещё не перезаписаны.

---

### **Заключение**

Таким образом, переменные и константы в C++ — это фундаментальные элементы управления данными, требующие глубокого понимания их жизненного цикла, размещения в памяти, правил именования и инициализации. Современный C++ предоставляет мощные инструменты (`const`, `constexpr`, `auto`, умные указатели), позволяющие писать безопасный, эффективный и читаемый код. Владение этими концепциями критически важно для успешной разработки и сдачи экзаменов.

---

 **Билет 3. «Типы данных в языке C++»**
---

Тип данных в языке C++ — это характеристика, определяющая:
- возможные значения переменной,
- операции, которые можно над ней выполнять,
- объём занимаемой памяти,
- способ представления в памяти.

Типизация в C++ **строгая и статическая**: тип переменной проверяется на этапе компиляции и не может меняться во время выполнения. Это обеспечивает безопасность, эффективность и предсказуемость программы.

---

### **1. Зачем нужны типы?**

Типы необходимы по нескольким причинам:
- **Безопасность**: компилятор проверяет корректность операций (нельзя сложить строку с указателем без явного преобразования).
- **Эффективность**: компилятор знает, сколько памяти выделить и как интерпретировать биты.
- **Абстракция**: типы позволяют моделировать реальные объекты (например, `Student`, `Matrix`).
- **Оптимизация**: знание типа позволяет генерировать эффективный машинный код.

---

### **2. Простые (встроенные) типы данных**

#### **Целые числа (`int`, `short`, `long`, `long long`, с модификаторами `signed`/`unsigned`)**

- **Объявление**:
  ```cpp
  int age = 20;
  unsigned short count = 1000;
  ```

- **Допустимые значения (примеры)**:
  - `int`: от −2 147 483 648 до +2 147 483 647 (на 32-битных системах)
  - `unsigned int`: от 0 до 4 294 967 295
  - `char`: от −128 до 127 (`signed char`) или 0–255 (`unsigned char`)

- **Допустимые операторы**:
  - Арифметические: `+`, `-`, `*`, `/`, `%`
  - Побитовые: `&`, `|`, `^`, `<<`, `>>`
  - Сравнения: `==`, `!=`, `<`, `>`, `<=`, `>=`
  - Инкремент/декремент: `++`, `--`

#### **Вещественные числа (`float`, `double`, `long double`)**

- Представляют дробные значения с плавающей точкой.
- Пример:
  ```cpp
  double pi = 3.1415926535;
  float price = 19.99f;
  ```
- Поддерживают арифметические операции, но **не поддерживают `%`**.
- Имеют ограниченную точность → возможны ошибки округления.

#### **Булев тип (`bool`)**

- Может принимать два значения: `true` (обычно 1) и `false` (0).
- Используется в условиях и логических выражениях:
  ```cpp
  bool is_valid = (x > 0);
  if (is_valid) { ... }
  ```

#### **Символьный тип (`char`, `wchar_t`, `char16_t`, `char32_t`)**

- Хранит один символ (в кодировке, зависящей от платформы).
- Пример:
  ```cpp
  char letter = 'A';
  wchar_t wide_char = L'Ω';
  ```
- Фактически — целое число, поэтому допустимы арифметические операции:
  ```cpp
  char next = letter + 1; // 'B'
  ```

---

### **3. Строки**

C++ поддерживает два основных подхода к строкам:

- **C-стиль**: массив символов, завершённый нулём (`'\0'`):
  ```cpp
  char name[] = "Alice";
  ```
- **C++-стиль**: класс `std::string` из стандартной библиотеки:
  ```cpp
  #include <string>
  std::string name = "Alice";
  ```
  Преимущества `std::string`: автоматическое управление памятью, безопасность, богатый интерфейс (`size()`, `substr()`, `+` для конкатенации).

---

### **4. Указатели (без углубления)**

Указатель — это переменная, хранящая **адрес другой переменной**.

- Объявление:
  ```cpp
  int x = 10;
  int* ptr = &x; // ptr хранит адрес x
  ```
- Операции: разыменование (`*ptr`), получение адреса (`&x`).
- Указатели могут быть `nullptr` (нулевой указатель).
- Тип указателя определяет, как интерпретировать данные по адресу.

---

### **5. Ссылки**

Ссылка — это **псевдоним** для существующей переменной.

- **lvalue-ссылки** (обычные):
  ```cpp
  int x = 5;
  int& ref = x; // ref — другое имя для x
  ref = 10;     // x теперь 10
  ```
- Ссылка **должна быть инициализирована** при объявлении.
- Не может быть «нулевой».
- Часто используется в параметрах функций для передачи по ссылке (без копирования).

*(rvalue-ссылки (`T&&`) в рамках билета не требуются, так как указано «без углубления»)*

---

### **6. Составные типы данных**

#### **Массивы**

- **Одномерные**:
  ```cpp
  int arr[5] = {1, 2, 3, 4, 5};
  ```
  Фиксированный размер, размещаются на стеке (если не `new`).

- **Многомерные**:
  ```cpp
  int matrix[3][3]; // матрица 3×3
  ```
  Реализованы как массивы массивов.

> ⚠️ В современном C++ рекомендуется использовать `std::array` (фиксированный размер) или `std::vector` (динамический).

#### **Перечисления**

- **Обычный `enum`**:
  ```cpp
  enum Color { Red, Green, Blue };
  ```
  Значения неявно преобразуются к `int`.

- **`enum class` (scoped enum)** — безопаснее:
  ```cpp
  enum class Status { Ok, Error };
  Status s = Status::Ok; // нельзя неявно привести к int
  ```

#### **Структуры (`struct`)**

Группируют данные разных типов:
```cpp
struct Point {
    double x, y;
};
Point p{1.0, 2.0};
```
По умолчанию — все поля `public`.

#### **Объединения (`union`)**

Хранят **только одно** из полей в один момент времени (все поля используют одну и ту же память):
```cpp
union Data {
    int i;
    float f;
};
```
Используются редко, в основном для низкоуровневых задач.

#### **Классы (`class`)**

Основа объектно-ориентированного программирования:
- Инкапсуляция, наследование, полиморфизм.
- По умолчанию — все поля `private`.
- Могут содержать данные и методы.

Пример:
```cpp
class Rectangle {
private:
    double width, height;
public:
    double area() const { return width * height; }
};
```

---

### **7. Неполные типы**

#### **Какие типы могут быть неполными?**
- Классы, структуры, объединения, перечисления — **до их определения**.
- Также: `void` (неполный, но особый).

Пример:
```cpp
class MyClass; // неполное объявление (forward declaration)
```

#### **Зачем нужны?**
- Для объявления указателей или ссылок без полного определения.
- Для разрешения взаимных зависимостей между классами.
- Для ускорения компиляции (не нужно включать заголовок целиком).

#### **Как использовать?**
- Можно объявлять указатели и ссылки:
  ```cpp
  MyClass* ptr; // OK
  ```
- **Нельзя**: создавать объекты, вызывать методы, получать размер (`sizeof`).

Полное определение должно быть доступно **до первого использования**, требующего знания структуры типа.

---

### **8. Преобразование типов**

#### **Неявное (автоматическое)**
Происходит без участия программиста:
```cpp
int a = 5;
double b = a; // int → double (без потерь)
```
Может приводить к **сужающим преобразованиям** (с потерей данных) — компилятор может выдать предупреждение.

#### **Явное**
Программист чётко указывает преобразование.

##### **В стиле C** (не рекомендуется в C++)
```cpp
int x = (int)3.14;
int y = int(3.14);
```
Опасно: обходит систему типов.

##### **В стиле C++ (операторы приведения)**

- **`static_cast`** — безопасные преобразования внутри иерархии типов:
  ```cpp
  double d = 3.14;
  int i = static_cast<int>(d);
  ```

- **`dynamic_cast`** — безопасное приведение вниз по иерархии наследования (требует виртуальных функций):
  ```cpp
  Base* b = new Derived();
  Derived* d = dynamic_cast<Derived*>(b);
  ```

- **`const_cast`** — добавление/удаление `const`:
  ```cpp
  const int x = 5;
  int* p = const_cast<int*>(&x); // осторожно!
  ```

- **`reinterpret_cast`** — низкоуровневое, опасное преобразование (битовое reinterpretation):
  ```cpp
  int* p = reinterpret_cast<int*>(some_ptr);
  ```
  Используется крайне редко (системное программирование).

---

### **Заключение**

Типы данных в C++ образуют иерархическую систему — от простых встроенных (`int`, `double`) до сложных пользовательских (`class`, `struct`). Понимание их свойств, особенностей и правил преобразования позволяет писать эффективный, безопасный и поддерживаемый код. Современный C++ активно использует строгую типизацию, составные типы и безопасные механизмы приведения, что делает язык мощным инструментом как для системного, так и для прикладного программирования.

---

**Билет 4. «Указатели в языке C++»**
---

Указатель — это одна из фундаментальных концепций языка C++, обеспечивающая **прямой доступ к памяти**. Он позволяет эффективно управлять ресурсами, реализовывать динамические структуры данных, передавать большие объекты без копирования и взаимодействовать с низкоуровневыми системами. Рассмотрим указатели во всех аспектах, требуемых программой.

---

### **1. Что такое указатель?**

Указатель — это **переменная**, которая хранит **адрес другой переменной** (или функции) в оперативной памяти.  
Оперативная память в C++ рассматривается как **линейная последовательность байтов**, каждый из которых имеет уникальный адрес.  
Адрес обычно записывается в **шестнадцатеричном виде** (например, `0x7fff2c01a3e4`).  
Важно: **адрес — это номер байта**, а не бита; получить адрес отдельного бита невозможно.

Пример:
```cpp
int x = 42;
std::cout << &x; // выводит адрес переменной x
```

---

### **2. Объявление указателя**

Синтаксис:
```cpp
Тип_данных* имя_указателя;
```

Примеры:
```cpp
int* p;
double* q;
std::string* s;
void* v; // сырой указатель
```

> **Важно**: звёздочка относится к **имени**, а не к типу. При объявлении нескольких переменных:
```cpp
int* a, b, c;   // a — указатель, b и c — обычные int
int* i, *j, k;  // i и j — указатели, k — int
```

---

### **3. Указатели и константность**

В C++ можно сделать **константным** как сам указатель, так и данные, на которые он указывает.

#### **Указатель на константу**:
```cpp
const int value = 10;
const int* ptr = &value; // нельзя изменить *ptr
```
Через такой указатель **запрещено изменять данные**, даже если исходная переменная не `const`.

#### **Константный указатель**:
```cpp
int x = 5, y = 10;
int* const ptr = &x; // ptr нельзя переназначить
// ptr = &y; // ОШИБКА
*ptr = 20; // OK — данные можно менять
```

#### **Константный указатель на константу**:
```cpp
const int* const ptr = &value;
// Нельзя ни менять адрес, ни значение
```

---

### **4. Декларация типов: правило чтения сложных объявлений**

Чтобы читать сложные объявления, используется **спиральное правило**:

> **«Направо → Налево → Наружу → Повторить»**

Примеры:

- `int* foo[7];`  
  → `foo` — **массив из 7 указателей на `int`**

- `int (*foo)[7];`  
  → `foo` — **указатель на массив из 7 `int`**

- `int (*foo[2])[3][3];`  
  → `foo` — **массив из 2 указателей на двумерный массив `3×3` типа `int`**

Это правило особенно полезно при работе с многомерными массивами и функциональными указателями.

---

### **5. Инициализация указателей**

Неинициализированный указатель содержит **мусорное значение** (случайный адрес) → использование приведёт к **неопределённому поведению**.

Способы инициализации:
- Адресом существующей переменной:  
  ```cpp
  int x = 5;
  int* p = &x;
  ```
- Специальным значением **нулевого указателя**:
  - `nullptr` (C++11, предпочтительно)
  - `NULL` (макрос из C, устаревший)

- Динамическим выделением памяти:
  ```cpp
  int* arr = new int[10];
  if (arr == nullptr) { /* ошибка */ }
  ```

---

### **6. Способы получения адреса**

Адрес можно получить **только у объектов с постоянным местом в памяти** (lvalue):
- Переменные: `&x`
- Функции: `&func` или просто `func` (имя функции автоматически преобразуется в адрес)

**Нельзя** получить адрес:
- Временных объектов: `&(x + y)`
- Литералов: `&42`

Тип указателя выводится как **тип переменной + `*`**:
```cpp
int x;
auto p = &x;     // p имеет тип int*
auto pp = &p;    // pp имеет тип int**
```

---

### **7. Виды указателей**

#### **Сырой указатель (`void*`)**
- Хранит адрес **любого типа**.
- **Не знает**, что лежит по этому адресу → **нельзя разыменовать напрямую**.
- Используется для совместимости с C (например, `malloc`, `memcpy`).

Пример:
```cpp
void* mem = malloc(16);
int* arr = static_cast<int*>(mem); // явное приведение обязательно
```

#### **Типизированный указатель**
- Хранит адрес **только определённого типа**.
- Позволяет **безопасно разыменовывать** и выполнять арифметику.

Пример:
```cpp
int x = 10;
int* p = &x;
*p += 5; // x теперь 15
```

---

### **8. Преобразование типа указателя**

#### **Для простых типов**
- Неявное преобразование **запрещено** (даже между `int*` и `double*`).
- Явное преобразование возможно:
  - В стиле C: `(int*)ptr`
  - В стиле C++: `static_cast<int*>(ptr)`

> **Важно**: при приведении **значение адреса не меняется**, но **интерпретация данных** — да.

Пример:
```cpp
int x = 1;
int* p = &x;
double* d = reinterpret_cast<double*>(p);
std::cout << *d; // мусор (биты int интерпретируются как double)
```

#### **Для сырых указателей (`void*`)**
- `void*` может принимать **любой адрес** без приведения.
- Обратное преобразование **требует явного приведения**.

#### **Для классов (с наследованием)**
- **Upcast** (к базовому классу): **безопасен**, выполняется **неявно**.
- **Downcast** (к производному): **потенциально опасен**, требует **явного приведения**.

Пример:
```cpp
struct A {};
struct B : A {};

B obj;
A* a = &obj;        // OK — upcast
B* b = static_cast<B*>(a); // downcast — программист берёт ответственность
```

Если класс имеет **виртуальные функции**, безопаснее использовать `dynamic_cast`, который проверяет тип во время выполнения:
```cpp
B* b = dynamic_cast<B*>(a); // вернёт nullptr, если a не указывает на B
```

---

### **9. Логические операции с указателями**

Указатели можно сравнивать:
- `==`, `!=` — чаще всего используются (например, проверка на `nullptr`)
- `<`, `>`, `<=`, `>=` — допустимы, но **только для указателей на элементы одного массива**

Пример:
```cpp
if (p != nullptr) { /* безопасно использовать */ }
```

---

### **10. Арифметика указателей**

Арифметика указателей **учитывает размер типа**:

- `p++` → сдвигает адрес **на `sizeof(T)` байт**
- `p + n` → сдвигает на `n * sizeof(T)` байт

Пример:
```cpp
int arr[3] = {10, 20, 30};
int* p = arr; // arr "распадается" до &arr[0]
++p;          // теперь p указывает на arr[1]
```

**Вычитание указателей**:
```cpp
int* q = p + 2;
std::cout << q - p; // выводит 2 (количество элементов, а не байт!)
```

**Сложение двух указателей — запрещено**.

---

### **11. Доступ к памяти через указатель**

Два способа:

1. **Оператор разыменования `*`**:
   ```cpp
   *p = 100;
   ```

2. **Синтаксис массива `[]`**:
   ```cpp
   p[0] = 100; // эквивалентно *p
   p[1] = 200; // эквивалентно *(p + 1)
   ```

> Интересный факт: в C++ выражение `5[p]` эквивалентно `p[5]`, так как `a[b]` → `*(a + b)`.

---

### **12. Связь с массивами (Array Decay)**

Массив и указатель — **разные вещи**, но:
- Имя массива **неявно преобразуется** в указатель на первый элемент (**array decay**).

Пример:
```cpp
int arr[10];
int* p = arr; // OK — decay
```

> **Важно**: decay применяется **только к первому измерению**:
```cpp
int matrix[3][4];
int (*p)[4] = matrix; // OK — указатель на строку
// int** q = matrix;  // ОШИБКА!
```

При передаче в функцию:
```cpp
void f(int arr[]);      // эквивалентно void f(int* arr);
void f(int arr[100]);   // тоже эквивалентно int*
```

---

### **13. Размер указателя**

Все указатели **одинакового размера** на данной платформе:
- **32-битная система**: 4 байта
- **64-битная система**: 8 байт

Пример:
```cpp
sizeof(int*) == sizeof(double*) == sizeof(void*) // true
```

Указатель хранит **только адрес начала объекта**. Информация о размере объекта содержится в **типе указателя**, а не в самом указателе.

---

### **14. Указатели в ООП**

#### **Upcast (вверх по иерархии)**
- Всегда безопасен: объект производного класса **содержит подобъект базового**.
- Адрес может **смещаться** (если множественное наследование).

Пример:
```cpp
struct A { int a; };
struct B { int b; };
struct C : A, B { int c; };

C obj;
A* pa = &obj; // адрес совпадает с началом obj
B* pb = &obj; // адрес смещён на sizeof(A)
```

#### **Downcast (вниз по иерархии)**
- Опасен, если реальный тип объекта **не совпадает** с целевым.
- Может привести к **выходу за границы памяти**.

#### **Безопасный downcast**
- Если класс имеет **виртуальные функции**, используйте `dynamic_cast`:
  ```cpp
  Base* b = new Derived();
  Derived* d = dynamic_cast<Derived*>(b); // nullptr, если несовместимо
  ```

---

### **Заключение**

Указатели — мощный, но ответственный инструмент. Они лежат в основе динамического управления памятью, полиморфизма, работы с массивами и системного программирования. Современный C++ стремится минимизировать прямое использование «сырых» указателей в пользу **умных указателей** (`unique_ptr`, `shared_ptr`) и контейнеров (`vector`, `array`), но понимание указателей остаётся **ключевым** для глубокого владения языком и успешной сдачи экзаменов.

---

**Билет 5. «Поток исполнения программы на языке C++»**
---

Поток исполнения (control flow) — это **порядок**, в котором выполняются инструкции программы. В C++ этот порядок строго определён синтаксисом языка, семантикой операторов и правилами вычисления выражений. Программа начинается с точки входа и далее следует по заданному маршруту, который может изменяться с помощью условных конструкций, циклов, вызовов функций и операторов перехода. Рассмотрим все элементы управления потоком подробно.

---

### **1. Точка входа в программу**

Точка входа — это функция `main()`, с которой начинается выполнение программы. Существует два стандартных варианта:

```cpp
int main();
int main(int argc, char* argv[]);
```

- `argc` — количество аргументов командной строки (включая имя программы),
- `argv` — массив строк с аргументами.

Если `main` не содержит `return`, компилятор автоматически добавляет `return 0;`.

> **Важно**: `main` **не может быть перегружена**, не может быть членом класса и не может вызываться рекурсивно.

---

### **2. Операторы, выражения, приоритет и ассоциативность**

#### **Выражение (expression)**
Выражение — это комбинация **операндов и операторов**, которая **вычисляет значение**.  
Примеры:
```cpp
x + 5
func()
a = b = 0
```

#### **Оператор (statement)**
Оператор — это **инструкция**, которая выполняет действие. Он **не обязан возвращать значение** и завершается точкой с запятой.  
Примеры:
```cpp
x = 5;               // expression statement
if (x > 0) { ... }   // selection statement
return 0;            // jump statement
```

> **Ключевое отличие**:  
> - **Выражение** → вычисляет значение.  
> - **Оператор** → выполняет действие (может содержать выражение).

#### **Приоритет операторов**
Определяет, какие операторы выполняются первыми в отсутствие скобок.  
Пример:
```cpp
a + b * c  // сначала *, потом +
```

#### **Ассоциативность**
Определяет порядок вычисления при равном приоритете:
- Левоассоциативные: `a - b - c` → `(a - b) - c`
- Правоассоциативные: `a = b = c` → `a = (b = c)`

> ⚠️ Не путайте ассоциативность с **порядком вычисления операндов** — он **не гарантирован** (см. ниже).

---

### **3. Что такое выражение?**

Выражение — любая конструкция, которая:
- имеет тип,
- имеет значение (или является `void`),
- может быть использована в других выражениях или как часть оператора.

Примеры:
- Литералы: `42`, `"hello"`
- Переменные: `x`
- Вызовы функций: `sqrt(2.0)`
- Комбинации: `(x + y) * z`

Выражения могут быть **lvalue** (имеют адрес, например, переменные) или **rvalue** (временные значения).

---

### **4. Порядок вычислений**

C++ **не гарантирует** порядок вычисления **операндов** бинарных операторов (кроме `&&`, `||`, `,`, `?:`).

Пример:
```cpp
f() + g()  // f() и g() могут вызываться в любом порядке
```

Однако **точки следования** (sequence points) гарантируют завершение всех побочных эффектов до определённого момента:
- Конец полного выражения (`;`)
- После вычисления условия в `if`, `while`, `for`
- Между вычислением условия и телом в `?:`, `&&`, `||`

> **Правило**: не допускайте зависимостей от порядка вычисления независимых подвыражений.

---

### **5. Statement vs Expression**

| Характеристика        | Выражение (Expression)       | Оператор (Statement)             |
|-----------------------|------------------------------|----------------------------------|
| Возвращает значение?  | Да (или `void`)              | Нет (но может содержать выражение) |
| Завершается `;`?      | Нет (если не в составе stmt) | Да                               |
| Пример                | `x + 1`, `func()`            | `x++;`, `if (...) {}`, `return;` |

> Особый случай: **expression statement** — выражение с `;` в конце:  
> ```cpp
> x = 5;   // выражение `x = 5` становится оператором
> ```

---

### **6. Гарантии относительно порядка исполнения**

C++ гарантирует:
- **Последовательное выполнение операторов** сверху вниз.
- **Полное вычисление** одного оператора перед началом следующего.
- **Порядок инициализации глобальных переменных** в одном файле — сверху вниз.
- **Порядок вычисления аргументов функции — не гарантирован**.

> Исключения: многопоточность (без синхронизации — гонки данных).

---

### **7. Statement-блок (compound statement)**

Блок — это группа операторов, заключённых в фигурные скобки `{}`. Он рассматривается как **один оператор**.

Пример:
```cpp
if (x > 0) {
    cout << "Positive";
    x *= 2;
}
```

Блок создаёт **новую область видимости**: переменные, объявленные внутри, уничтожаются при выходе.

---

### **8. Операторы выбора**

#### **`if`**
Условное ветвление:
```cpp
if (condition) {
    // если true
} else if (another) {
    // ...
} else {
    // если все false
}
```

> Условие должно быть **конвертируемо в `bool`**.

#### **`switch`**
Множественный выбор по **целочисленному значению**:
```cpp
switch (value) {
    case 1: ... break;
    case 2: ... break;
    default: ...
}
```

> ⚠️ Без `break` — **проваливание** (fall-through).  
> Переменные в `case` требуют блока:  
> ```cpp
> case 1: {
>     int x = 10;
>     ...
>     break;
> }
> ```

#### **Тернарный оператор `?:`**
Сокращённая форма `if-else`:
```cpp
result = (x > 0) ? x : -x;
```

> Гарантирован **порядок вычисления**: сначала условие, затем **только один** из операндов.

---

### **9. Операторы цикла**

#### **`for` (классический)**
```cpp
for (init; condition; increment) {
    // тело
}
```
Этапы:
1. Инициализация (один раз)
2. Проверка условия → если `false`, выход
3. Тело
4. Инкремент → возврат к шагу 2

#### **range-based `for` (C++11)**
Итерация по контейнеру или массиву:
```cpp
for (auto& elem : container) {
    elem *= 2;
}
```
Работает с любым типом, имеющим `begin()`/`end()`.

#### **`while`**
Проверка **до** тела:
```cpp
while (condition) {
    // тело
}
```

#### **`do-while`**
Проверка **после** тела (тело выполняется хотя бы один раз):
```cpp
do {
    // тело
} while (condition);
```

---

### **10. Операторы перехода**

#### **`goto` и метки**
Переход на **метку** в том же теле функции:
```cpp
start:
    ...
    goto start;
```

> **Редко используется** (считается вредным), но допустим в исключительных случаях (например, выход из вложенных циклов).

#### **`break`**
- Прерывает выполнение **ближайшего** `switch`, `for`, `while`, `do-while`.
- Передаёт управление за пределы конструкции.

#### **`continue`**
- Пропускает остаток тела цикла и переходит к **следующей итерации**.

---

### **11. Функция и поток исполнения**

Вызов функции **прерывает текущий поток**, сохраняет состояние (возвратный адрес, регистры) и передаёт управление в тело функции. После `return` управление возвращается в точку вызова.

Особенности:
- Аргументы вычисляются **до входа** в функцию (порядок не гарантирован).
- Локальные переменные создаются при входе, уничтожаются при выходе.
- Рекурсия допустима (ограничена размером стека).

Функции — основной механизм **структурного программирования**, позволяющий разбивать логику на модули.

---

### **Заключение**

Поток исполнения в C++ строится на строгой иерархии управляющих конструкций: от простых выражений до сложных ветвлений и циклов. Понимание приоритетов, ассоциативности, порядка вычислений и семантики операторов позволяет писать предсказуемый и эффективный код. Современный C++ поощряет использование **структурных** (а не `goto`) подходов, что повышает читаемость и снижает вероятность ошибок. Владение этими концепциями — ключ к успешной алгоритмизации и программированию.

---

**Билет 6. «Функции в языке C++»**
---

Функция — это **фундаментальная единица модульности и повторного использования кода** в C++. Она инкапсулирует логически завершённую последовательность действий, имеет чётко определённый интерфейс (параметры и возвращаемое значение) и может быть вызвана из любого места программы. Современный C++ предоставляет богатый арсенал возможностей для работы с функциями: от классических объявлений до лямбд, `constexpr`, `inline` и безопасной передачи данных. Рассмотрим все аспекты подробно.

---

### **1. Объявление функции**

#### **Правила и структура**
Объявление (прототип) функции сообщает компилятору:
- имя функции,
- тип возвращаемого значения,
- список параметров (их типы и порядок).

Синтаксис:
```cpp
[спецификаторы] возвращаемый_тип имя(тип1 парам1, тип2 парам2, ...);
```

Пример:
```cpp
int add(int a, int b);  // объявление
```

Объявление **не содержит тела** (`{}`), но **обязательно завершается точкой с запятой**.

> Объявление может находиться в заголовочном файле (`.h`) и использоваться во многих `.cpp`-файлах.

---

### **2. Объявление функции внутри функции**

В C++ **нельзя объявлять обычные именованные функции внутри другой функции**:
```cpp
void outer() {
    void inner(); // ❌ ОШИБКА: нельзя объявлять функцию внутри функции
}
```

Однако разрешены:
- **Лямбда-выражения** (см. ниже),
- **Объявление через `extern`**, если функция определена глобально:
  ```cpp
  void outer() {
      extern void helper(); // OK — ссылка на внешнюю функцию
      helper();
  }
  ```

---

### **3. Лямбда-функции**

Лямбда — это **анонимная функция**, определяемая **непосредственно в месте использования** (часто как аргумент алгоритма).

Синтаксис:
```cpp
[захват](параметры) -> возвращаемый_тип { тело }
```

Пример:
```cpp
auto square = [](int x) { return x * x; };
std::cout << square(5); // 25
```

- **Захват (`[]`)** позволяет использовать переменные из окружающей области:
  - `[=]` — захват по значению,
  - `[&]` — захват по ссылке,
  - `[x, &y]` — явный захват.

Лямбды особенно полезны с STL (`std::sort`, `std::for_each` и др.).

---

### **4. Ключевые слова**

#### **`constexpr`**
Указывает, что функция **может быть вычислена на этапе компиляции**, если аргументы — константные выражения:
```cpp
constexpr int factorial(int n) {
    return (n <= 1) ? 1 : n * factorial(n - 1);
}
constexpr int f = factorial(5); // вычислено при компиляции
```

#### **`consteval`** (C++20)
Гарантирует, что функция **всегда** вычисляется на этапе компиляции:
```cpp
consteval int always_compile_time(int x) { return x * 2; }
// вызов во время выполнения → ошибка компиляции
```

#### **`extern`**
Указывает, что функция **определена в другом файле**:
```cpp
// file1.cpp
int foo() { return 42; }

// file2.cpp
extern int foo(); // объявление без определения
```

> Для функций `extern` часто опускается, так как по умолчанию они имеют **внешнее связывание**.

#### **`extern "C"`**
Отключает **name mangling** (искажение имён), чтобы обеспечить совместимость с C:
```cpp
extern "C" {
    void c_function(int x); // будет искаться как _c_function, а не __Z11c_functioni
}
```
Используется при написании библиотек, вызываемых из C.

#### **`static`** (для функций)
Ограничивает **видимость функции текущим файлом** (внутреннее связывание):
```cpp
static void helper() { ... } // недоступна из других .cpp
```

#### **`inline`**
Подсказка компилятору: **встроить тело функции** вместо вызова (уменьшает накладные расходы).
```cpp
inline int max(int a, int b) { return (a > b) ? a : b; }
```
> Современные компиляторы часто игнорируют `inline` как подсказку, но **требуют его для определения в заголовках** (чтобы не нарушать ODR).

---

### **5. Параметры функции**

#### **Параметры-значения**
Передаётся **копия** аргумента:
```cpp
void f(int x) { x = 10; } // оригинал не изменится
```

#### **Параметры-указатели**
Передаётся **адрес**:
```cpp
void f(int* p) { *p = 10; } // оригинал изменится
```

#### **Параметры-ссылки**
Передаётся **псевдоним** (без копирования):
```cpp
void f(int& x) { x = 10; } // оригинал изменится
```
Часто используется для больших объектов или модификации.

#### **Параметр-указатель на функцию**
Позволяет передавать функции как аргументы:
```cpp
int apply(int (*func)(int), int x) {
    return func(x);
}
int square(int x) { return x * x; }
apply(square, 5); // 25
```

#### **Параметры со значением по умолчанию**
Указываются в **объявлении** (обычно в `.h`):
```cpp
void greet(std::string name = "Guest") {
    std::cout << "Hello, " << name;
}
greet();        // Hello, Guest
greet("Alice"); // Hello, Alice
```
> Значения по умолчанию должны идти **справа налево**.

---

### **6. Аргументы**

Аргументы — это **фактические значения**, передаваемые при вызове.  
Порядок вычисления аргументов **не гарантирован** (может повлиять на побочные эффекты).

---

### **7. Возврат значения из функции**

#### **Ничего не возвращать**
Функция с типом `void`:
```cpp
void log(const std::string& msg) { std::cout << msg; }
```

#### **Одно значение**
Возвращается через `return`:
```cpp
int add(int a, int b) { return a + b; }
```

> Можно возвращать:
> - значения (`int`),
> - ссылки (`int&`),
> - указатели (`int*`),
> - временные объекты (move semantics).

#### **Перегрузка**
Функции с **одинаковым именем**, но **разными параметрами**:
```cpp
void print(int x);
void print(double x);
void print(const std::string& s);
```
Разрешение перегрузки происходит на этапе компиляции.

---

### **8. Определение функции**

#### **Отличие от объявления**
- **Объявление**: только сигнатура + `;`
- **Определение**: сигнатура + тело `{}`

#### **One Definition Rule (ODR)**
Каждая функция, используемая в программе, должна иметь **ровно одно определение**.  
Исключение: `inline`-функции могут определяться в нескольких единицах трансляции, если **идентичны**.

#### **Определение в другом `.cpp` файле**
```cpp
// math.h
int add(int a, int b); // объявление

// math.cpp
#include "math.h"
int add(int a, int b) { return a + b; } // определение
```
Линкер свяжет вызов с определением.

---

### **9. Использование: вызов функции**

#### **Как вызвать**
```cpp
result = function_name(arg1, arg2);
```

#### **Процесс вызова по шагам**
1. Вычисление аргументов (порядок не гарантирован).
2. Передача аргументов (по значению/ссылке/указателю).
3. Сохранение возвратного адреса и регистра состояния.
4. Переход в тело функции.
5. Выполнение тела.
6. Возврат значения (если есть).
7. Возврат управления в точку вызова.

---

### **10. Связывание имени функции**

#### **Статическое (лексическое) связывание**
Имя функции связывается с адресом **на этапе компиляции** (для обычных и `inline` функций).

#### **Динамическое связывание**
Применяется **только к виртуальным функциям** в ООП (через таблицу виртуальных методов).  
Для обычных функций — **не используется**.

---

### **11. Рекурсия**

Функция вызывает **саму себя**. Требует:
- **Базового случая** (условия выхода),
- **Сведения задачи** к более простой.

#### **Стек вызовов**
Каждый вызов создаёт **новую запись в стеке** (локальные переменные, параметры, возвратный адрес).  
При возврате запись удаляется.

#### **Возврат из рекурсивной функции**
Происходит **по цепочке**: от самого глубокого вызова к первому.

> ⚠️ Глубокая рекурсия → переполнение стека.

---

### **12. Функция `main`**

#### **Параметры**
```cpp
int main(int argc, char* argv[]);
```
- `argc` — число аргументов командной строки,
- `argv` — массив строк (`argv[0]` — имя программы).

#### **Возвращаемое значение**
- `0` или `EXIT_SUCCESS` — успех,
- Ненулевое (`EXIT_FAILURE`) — ошибка.

Если `return` отсутствует — компилятор добавляет `return 0;`.

> **Особенности `main`**:
> - Не может быть `static`, `inline`, `constexpr`,
> - Не может вызываться рекурсивно,
> - Не может быть перегружена.

---

### **Заключение**

Функции в C++ — это не просто блоки кода, а мощный инструмент абстракции, оптимизации и повторного использования. От классических функций до лямбд, от `constexpr` до `inline`, от передачи по значению до указателей на функции — язык предоставляет гибкие и безопасные механизмы. Понимание этих концепций позволяет писать эффективные, читаемые и надёжные программы, а также успешно сдавать экзамены на высокий балл.

---

**Билет 7. «Работа с идентификаторами в C++»**
---

Идентификатор — это имя, которое программист присваивает сущностям программы: переменным, функциям, типам, макросам и другим элементам. В C++ работа с идентификаторами строго регламентирована правилами именования, областями видимости и механизмами связывания. Эти правила обеспечивают читаемость кода, предотвращают конфликты имён и позволяют эффективно управлять ресурсами. Рассмотрим все аспекты подробно.

---

### **1. Допустимые идентификаторы**

#### **Общие правила именования**
Идентификатор в C++:
- Может содержать **латинские буквы** (`a–z`, `A–Z`), **цифры** (`0–9`) и **символ подчёркивания** (`_`);
- **Не может начинаться с цифры**;
- **Чувствителен к регистру**: `count`, `Count`, `COUNT` — разные идентификаторы;
- **Не может совпадать с ключевыми словами** (`int`, `return`, `class`, `if` и т.д.);
- Не должен начинаться с двух подчёркиваний (`__name`) или с подчёркивания и заглавной буквы (`_Name`) — такие имена **зарезервированы** для компилятора и стандартной библиотеки.

Эти правила **едины** для всех сущностей: переменных, функций, типов и т.д.

#### **Для переменных и функций**
Примеры допустимых имён:
```cpp
int user_age;
double calculateTax(double income);
std::string userName;
```

Рекомендуется использовать:
- **camelCase** (`userName`) или **snake_case** (`user_name`) — в зависимости от стиля проекта.

#### **Для макросов**
Макросы (определённые через `#define`) **традиционно пишутся заглавными буквами**:
```cpp
#define MAX_SIZE 100
#define PI 3.14159
```
Это соглашение помогает отличать макросы от обычных переменных и функций, так как они обрабатываются препроцессором **до компиляции** и не подчиняются обычным правилам области видимости.

> ⚠️ Макросы **не являются частью C++ как языка**, а относятся к препроцессору C. Их использование в современном C++ **минимизируется** в пользу `constexpr`, `const`, `inline` и шаблонов.

---

### **2. Области видимости (Scope)**

Область видимости — это **часть программы**, в которой идентификатор **доступен**.

#### **Глобальная область видимости**
- Определяется **вне всех функций и блоков**.
- Переменные и функции видны **во всей единице трансляции** (`.cpp`-файле).
- Пример:
  ```cpp
  int global_var = 42; // глобальная переменная
  void helper() { ... } // глобальная функция
  ```

> ⚠️ Избыточное использование глобальных переменных **нарушает инкапсуляцию** и усложняет тестирование.

#### **Локальная область видимости**
- Определяется **внутри функции или блока `{}`**.
- Существует несколько уровней:
  - **Функциональная**: параметры и переменные внутри функции.
  - **Блочная**: переменные внутри циклов, условий, `{}`.

Пример:
```cpp
void func() {
    int x = 10; // локальная
    if (true) {
        int y = 20; // локальная в блоке
    }
    // y недоступна здесь
}
```

#### **Скрытие (Shadowing)**
Если вложенный блок объявляет переменную с тем же именем, что и во внешнем блоке, **внешняя переменная скрывается**:

```cpp
int x = 100; // глобальная
void func() {
    int x = 200; // скрывает глобальную
    {
        int x = 300; // скрывает локальную
        std::cout << x; // 300
    }
}
```

> Скрытие **не запрещено**, но может привести к ошибкам. Многие компиляторы выдают предупреждение (`-Wshadow` в GCC/Clang).

---

### **3. Связь области видимости и времени жизни переменной**

- **Время жизни** — период, в течение которого объект существует в памяти.
- **Область видимости** — период, в течение которого имя объекта можно использовать.

#### **Для автоматических (локальных) переменных**
- **Время жизни = области видимости**: создаются при входе в блок, уничтожаются при выходе.
- Пример:
  ```cpp
  void f() {
      int x = 5; // создаётся
  } // x уничтожается
  ```

#### **Для статических переменных**
- **Глобальные статические**: время жизни — всё выполнение программы.
- **Локальные статические**: инициализируются **один раз**, живут до завершения программы:
  ```cpp
  void counter() {
      static int count = 0; // инициализация — один раз
      ++count;
  }
  ```

#### **Для динамических переменных (`new`)**
- Время жизни **не связано** с областью видимости указателя:
  ```cpp
  int* p = new int(42);
  // p выходит из области видимости → утечка, если не delete
  ```

> Таким образом, **область видимости ≠ время жизни** для динамических объектов.

---

### **4. Связывание имени с программной сущностью (Binding)**

Связывание — это процесс **привязки имени к конкретной сущности** (переменной, функции и т.д.).

#### **Статическое (лексическое) связывание**
- Происходит **на этапе компиляции**.
- Имя связывается с адресом или реализацией **до запуска программы**.
- Применяется ко **всем обычным функциям, переменным, перегрузкам**.

Пример:
```cpp
void foo() { ... }
foo(); // компилятор знает, какую функцию вызывать
```

#### **Динамическое связывание**
- Происходит **во время выполнения**.
- Применяется **только к виртуальным функциям** в ООП.
- Реализуется через **таблицу виртуальных методов (vtable)**.

Пример:
```cpp
struct Base {
    virtual void f() { std::cout << "Base"; }
};
struct Derived : Base {
    void f() override { std::cout << "Derived"; }
};

Base* p = new Derived();
p->f(); // вызов определяется во время выполнения → "Derived"
```

> Для **переменных** динамическое связывание **не применяется** — все переменные связываются статически.

---

### **Заключение**

Идентификаторы в C++ — это не просто имена, а ключевой элемент архитектуры программы. Правильное именование, понимание областей видимости, управление временем жизни и знание механизмов связывания позволяют писать чистый, безопасный и эффективный код. Современный C++ поощряет локальность, минимизацию глобального состояния и использование статического связывания, где это возможно, оставляя динамическое связывание только для случаев полиморфизма. Владение этими концепциями — основа успешного программирования и высокой оценки на экзамене.

---

**Билет 8. «OOП в C++. Основные понятия»**
---

Класс — это фундаментальный строительный блок объектно-ориентированного программирования в C++. Он инкапсулирует **данные** (поля) и **поведение** (методы), обеспечивая механизмы абстракции, инкапсуляции, наследования и полиморфизма. Рассмотрим все аспекты классов, требуемые программой экзамена.

---

### **1. Объявление класса. Разница между `struct` и `class`**

Объявление класса задаёт его интерфейс и внутреннюю структуру:

```cpp
class MyClass {
    // тело класса
};
```

#### **Разница между `struct` и `class`**
- **Единственное различие** — **уровень доступа по умолчанию**:
  - В `class` — `private`
  - В `struct` — `public`

Пример:
```cpp
struct S { int x; };   // x — public
class C { int x; };    // x — private
```

> Во всём остальном (`наследование`, `методы`, `статические члены`) они **полностью эквивалентны**.

---

### **2. Поля класса**

Поля — это переменные, принадлежащие объекту или классу в целом.

#### **Объявление**
```cpp
class Point {
    double x, y; // private по умолчанию
};
```

#### **Инициализация**
- **Нестатические поля** инициализируются в **конструкторе** (через список инициализации):
  ```cpp
  Point(double a, double b) : x(a), y(b) {}
  ```
- Начиная с C++11, можно использовать **инициализацию при объявлении**:
  ```cpp
  int count = 0;
  ```

#### **Доступ**
Управляется квалификаторами:
- `public` — доступ извне,
- `private` — только из методов самого класса,
- `protected` — из методов класса и его потомков.

#### **Константные поля**
```cpp
const int id;
```
Должны быть инициализированы в **списке инициализации конструктора** (присваивание в теле — запрещено).

#### **Указатели и ссылки как поля**
- Указатели — допустимы, но требуют ручного управления памятью.
- Ссылки **должны быть инициализированы при создании объекта** (в конструкторе):
  ```cpp
  class Wrapper {
      int& ref;
  public:
      Wrapper(int& r) : ref(r) {}
  };
  ```

#### **Ключевое слово `mutable`**
Позволяет изменять поле даже внутри `const`-метода:
```cpp
class Cache {
    mutable bool dirty = false;
public:
    void update() const { dirty = true; } // OK благодаря mutable
};
```

---

### **3. Статические поля класса (`static`)**
Принадлежат **классу в целом**, а не отдельному объекту. Все объекты разделяют одно значение.

#### **Объявление**
```cpp
class Counter {
    static int total;
};
```

#### **Определение и инициализация**
Вне класса, в одном `.cpp`-файле:
```cpp
int Counter::total = 0;
```

> Исключение: **константные целочисленные статические поля** могут инициализироваться **внутри класса**:
```cpp
static const int MAX = 100;
```

#### **Доступ**
- Через имя класса: `Counter::total`
- Из методов — напрямую: `total`

#### **Константные статические поля**
Могут использоваться как **константные выражения** (например, размер массива):
```cpp
static constexpr double PI = 3.14159;
```

---

### **4. Методы класса**

#### **Способы определения**
- **Внутри класса** — автоматически считаются `inline`:
  ```cpp
  void print() { std::cout << x; }
  ```
- **Вне класса** — требуется указать область видимости:
  ```cpp
  void Point::print() { std::cout << x; }
  ```

#### **Методы объекта (нестатические)**
- Имеют неявный параметр `this` — указатель на текущий объект.
- Могут обращаться к **всем полям** объекта.

##### **Константные и неконстантные версии**
Перегрузка по `const`:
```cpp
char& operator[](size_t i);       // неконстантный
const char& operator[](size_t i) const; // константный
```
Выбор зависит от того, `const` ли объект.

##### **Виртуальные методы**
Позволяют реализовать **полиморфизм**:
```cpp
virtual void draw() { ... }
```

##### **Чисто виртуальные (абстрактные) методы**
Делают класс **абстрактным** (нельзя создавать объекты):
```cpp
virtual void draw() = 0;
```

#### **Статические методы**
- Не имеют `this`.
- Не могут обращаться к **нестатическим** полям и методам.
- Вызываются через имя класса:
  ```cpp
  Counter::reset();
  ```

---

### **5. Ключевые слова `default` и `delete`**

- **`= default`** — просит компилятор сгенерировать **специальный метод** (конструктор, деструктор и т.д.):
  ```cpp
  Point() = default;
  ```

- **`= delete`** — **запрещает** использование метода:
  ```cpp
  Point(const Point&) = delete; // запрет копирования
  ```

Эти механизмы позволяют точно контролировать поведение класса.

---

### **6. Квалификаторы доступа**

| Квалификатор | Доступ из | Наследование |
|--------------|-----------|---------------|
| `public`     | Всюду     | Сохраняется   |
| `private`    | Только внутри класса | Скрывается |
| `protected`  | Класс + потомки | Доступен в потомках |

Пример наследования:
```cpp
class Base {};
class Derived : private Base {}; // Base становится private в Derived
```

---

### **7. Устройство объекта в памяти**

#### **Занимают ли методы место в памяти объекта?**
- **Нет.** Методы хранятся **отдельно от объектов** (в сегменте кода).
- Объект содержит **только поля**.

#### **Размер объекта**

- **Без виртуальных функций**:
  ```cpp
  class A { int x; }; // sizeof(A) == sizeof(int) (обычно 4)
  ```

- **С виртуальными функциями**:
  - Компилятор добавляет **указатель на таблицу виртуальных функций (vptr)**.
  - Размер увеличивается на размер указателя (8 байт на x64):
    ```cpp
    class B { virtual void f(); int x; }; // sizeof(B) == 12 (x86) или 16 (x64, с выравниванием)
    ```

> Пустой класс всё равно имеет размер ≥ 1 байт (чтобы разные объекты имели разные адреса).

---

### **Заключение**

Классы в C++ — это мощный механизм инкапсуляции данных и поведения. Они позволяют строить иерархии типов, управлять доступом, разделять состояние через статические члены и реализовывать полиморфизм через виртуальные функции. Современный C++ предоставляет точные инструменты (`= default`, `= delete`, `mutable`, `constexpr`) для контроля над каждым аспектом поведения класса. Глубокое понимание этих концепций — основа как системного, так и прикладного программирования, а также залог высокой оценки на экзамене.

---

**Билет 9. «ООП в C++. Спциальные члены-ффункции»**
---

Конструкторы и деструкторы — это специальные члены класса, отвечающие за **создание** и **уничтожение** объектов. Они обеспечивают корректную инициализацию ресурсов (память, файлы, соединения) и их освобождение, что критически важно для безопасности и надёжности программы. Рассмотрим все аспекты подробно.

---

### **1. Конструктор по умолчанию**

Конструктор по умолчанию — это конструктор **без параметров** или с **всеми параметрами по умолчанию**.

#### **Реализация, предоставляемая компилятором**
Если программист **не объявляет ни одного конструктора**, компилятор **автоматически генерирует** конструктор по умолчанию:
```cpp
class Point {
    int x, y;
}; // компилятор создаёт Point() = default;
```

> Однако если объявлен **хотя бы один** пользовательский конструктор, компилятор **не генерирует** конструктор по умолчанию автоматически. Чтобы восстановить его, нужно явно написать:
```cpp
Point() = default;
```

---

### **2. Конструктор с одним параметром и ключевое слово `explicit`**

Конструктор с одним параметром позволяет **неявное преобразование** из типа параметра в тип класса:

```cpp
class String {
public:
    String(int size); // позволяет: String s = 10;
};
String s = 42; // неявное преобразование int → String
```

Это может привести к **непреднамеренным ошибкам**.

#### **`explicit`**
Запрещает неявные преобразования:
```cpp
explicit String(int size);
// String s = 42; // ОШИБКА
String s(42);      // OK — явный вызов
```

> **Рекомендация**: всегда использовать `explicit` для одноаргументных конструкторов, если не требуется неявное преобразование.

---

### **3. Конструктор с несколькими параметрами**

Позволяет инициализировать объект сразу несколькими значениями:
```cpp
class Point {
    int x, y;
public:
    Point(int x, int y) : x(x), y(y) {}
};
Point p{1, 2}; // список инициализации (C++11)
```

Такие конструкторы **не участвуют в неявных преобразованиях**, даже без `explicit`.

---

### **4. Делегирующие конструкторы**

Один конструктор может вызывать другой конструктор **того же класса**:
```cpp
class Point {
    int x, y;
public:
    Point() : Point(0, 0) {}               // делегирование
    Point(int x, int y) : x(x), y(y) {}
};
```

Позволяет избежать дублирования кода инициализации.

---

### **5. Инициализация полей**

#### **Внутри тела конструктора**
```cpp
Point(int a, int b) {
    x = a; // присваивание, НЕ инициализация!
    y = b;
}
```
- Для **обычных типов** — допустимо.
- Для **констант**, **ссылок**, **объектов без конструктора по умолчанию** — **запрещено**.

#### **Список инициализаторов**
```cpp
Point(int a, int b) : x(a), y(b) {}
```
- Это **настоящая инициализация**.
- Обязательна для:
  - `const`-полей,
  - ссылок,
  - объектов без конструктора по умолчанию.

#### **Порядок инициализации полей**
- Поля инициализируются **в порядке объявления в классе**, **НЕ в порядке в списке инициализаторов**.
- Нарушение этого правила может привести к использованию неинициализированных значений.

#### **Инициализация в точке объявления**
Начиная с C++11:
```cpp
class Counter {
    int count = 0; // значение по умолчанию
};
```
Если в конструкторе есть список инициализаторов — он **переопределяет** значение по умолчанию.

---

### **6. Порядок вызова конструкторов при наследовании**

При создании объекта производного класса вызов происходит в следующем порядке:

1. Конструкторы **базовых классов** (слева направо в списке наследования).
2. Конструкторы **членов-объектов** (в порядке объявления).
3. Тело **конструктора производного класса**.

Пример:
```cpp
struct A { A() { cout << "A"; } };
struct B { B() { cout << "B"; } };
struct C : A, B { C() { cout << "C"; } };
// Вывод: ABC
```

---

### **7. Конструктор копирования**

Конструктор копирования создаёт **новый объект** как копию существующего:
```cpp
ClassName(const ClassName& other);
```

#### **Виды копирования**

- **Поверхностное (побитовое)** — просто копируются байты.  
  Подходит только для **POD-типов** (простых структур без указателей).

- **Глубокое** — выделяется новая память и копируются данные, на которые указывают указатели.  
  Обязательно для классов, управляющих ресурсами.

#### **Когда вызывается?**

- При **передаче объекта в функцию по значению**:
  ```cpp
  void f(MyClass obj); // вызов конструктора копирования
  ```
- При **возврате объекта из функции по значению**:
  ```cpp
  MyClass make() { return MyClass(); } // может вызвать копирование (или move)
  ```
- При **явном создании копии**:
  ```cpp
  MyClass a;
  MyClass b(a); // или MyClass b = a;
  ```

> Современные компиляторы часто применяют **оптимизацию возврата (RVO/NRVO)**, чтобы избежать лишнего копирования.

---

### **8. Оператор присваивания-копирования**

Оператор присваивания **копирует содержимое одного объекта в уже существующий**:
```cpp
ClassName& operator=(const ClassName& other);
```

#### **Общая схема реализации**
1. Проверка на **самоприсваивание** (`if (this == &other) return *this;`).
2. Освобождение старых ресурсов.
3. Выделение новых ресурсов и копирование данных.
4. Возврат `*this`.

#### **Когда вызывается конструктор копирования, а когда — оператор присваивания?**

| Ситуация | Вызывается |
|---------|------------|
| `MyClass a = b;` | Конструктор копирования |
| `MyClass a(b);` | Конструктор копирования |
| `a = b;` (после создания `a`) | Оператор присваивания |

#### **Идиома *copy-and-swap***

Безопасный и исключительно-безопасный способ реализации присваивания:
```cpp
ClassName& operator=(ClassName other) { // принимаем копию
    swap(*this, other);                // обмениваемся данными
    return *this;
}
```
- Самоприсваивание обрабатывается автоматически.
- Исключения безопасны (если копирование выбросит исключение — оригинал не повреждён).

Требует корректной реализации `swap`.

---

### **9. Деструктор**

Деструктор вызывается **автоматически** при уничтожении объекта:
```cpp
~ClassName();
```

#### **Порядок вызова при наследовании**

При уничтожении объекта производного класса:

1. Тело **деструктора производного класса**.
2. Деструкторы **членов-объектов** (в обратном порядке объявления).
3. Деструкторы **базовых классов** (в обратном порядке наследования).

Пример:
```cpp
struct A { ~A() { cout << "A"; } };
struct B { ~B() { cout << "B"; } };
struct C : A, B { ~C() { cout << "C"; } };
// Уничтожение объекта C → вывод: CBA
```

> **Важно**: деструктор базового класса **должен быть виртуальным**, если класс предназначен для наследования. Иначе при удалении через указатель на базовый класс деструктор производного **не вызовется** → утечка ресурсов.

---

### **Заключение**

Конструкторы и деструкторы — это основа управления жизненным циклом объектов в C++. Они обеспечивают корректную инициализацию, предотвращают утечки ресурсов и позволяют реализовать семантику владения (RAII). Понимание различий между инициализацией и присваиванием, поверхностным и глубоким копированием, а также правил порядка вызова при наследовании — ключ к написанию надёжного и эффективного кода. Владение этими концепциями гарантирует высокую оценку на экзамене и успешное применение C++ в реальных проектах.

---

**Билет 10. «ООП в C++. Наследование»**
---

Наследование — один из трёх столпов объектно-ориентированного программирования (наряду с инкапсуляцией и полиморфизмом). Оно позволяет создавать новые классы на основе существующих, **расширяя или изменяя их поведение**, при этом повторно используя уже написанный код. Это мощный механизм абстракции и иерархического моделирования реального мира.

---

### **1. Основная идея и принцип наследования**

Идея наследования — **моделирование иерархии «общее → частное»**.  
Класс-наследник (производный класс) **наследует** поля и методы базового (родительского) класса и может:
- использовать их без изменений,
- **переопределять** (override),
- **добавлять новые** члены.

Это способствует **повторному использованию кода**, **логической группировке** и **поддержке полиморфизма**.

---

### **2. Основные понятия**

- **Базовый класс (base class)** — класс, от которого наследуются другие.
- **Класс-наследник (derived class)** — класс, который наследует от базового.

Пример:
```cpp
class Animal { /* ... */ };
class Dog : public Animal { /* ... */ };
```
Здесь `Animal` — базовый, `Dog` — наследник.

---

### **3. Отношение «является» (is-a)**

Отношение **«объект класса-наследника *является* объектом базового класса»** называется **is-a**.

#### **Что это значит?**
Любой `Dog` — это `Animal`, но не любой `Animal` — `Dog`.

#### **Пример использования**
Полиморфизм:
```cpp
void feed(Animal& a); // можно передать Dog, Cat и т.д.
Dog d;
feed(d); // OK — Dog is-a Animal
```

Это лежит в основе **универсальных интерфейсов** и **гибких архитектур**.

---

### **4. Объявление наследования**

Синтаксис:
```cpp
class Derived : [способ] Base {
    // ...
};
```

Пример:
```cpp
class Rectangle : public Shape { };
```

Если не указан способ — по умолчанию `private` для `class`, `public` для `struct`.

---

### **5. Типы наследования**

#### **Одиночное**
Один базовый класс:
```cpp
class B {};
class D : public B {};
```

#### **Множественное**
Несколько базовых классов:
```cpp
class A {};
class B {};
class C : public A, public B {};
```

#### **Ромбовидное (diamond problem)**
Возникает при множественном наследовании от общего предка:
```cpp
    A
   / \
  B   C
   \ /
    D
```
Без специальных мер класс `D` будет содержать **два подобъекта `A`**, что приводит к неоднозначности.

---

### **6. Минусы множественного наследования**

- **Неоднозначность имён**: если два предка имеют метод с одинаковым именем — компилятор не знает, какой выбрать.
- **Увеличение сложности**: труднее понимать, откуда берётся поведение.
- **Проблема ромба**: дублирование подобъектов базового класса.
- **Сложность отладки и поддержки**.

> Поэтому многие языки (Java, C#) запрещают множественное наследование реализации, разрешая только интерфейсы.

---

### **7. Влияние порядка перечисления предков**

Порядок в списке наследования **влияет на порядок инициализации**:
```cpp
class D : public B, public A { };
```
→ Сначала вызывается конструктор `B`, затем `A`.

Также влияет на **расположение подобъектов в памяти** и **порядок уничтожения** (обратный).

---

### **8. Способы наследования**

| Способ       | Доступ к `public` членам базового | Доступ к `protected` | Видимость в наследнике |
|--------------|----------------------------------|----------------------|------------------------|
| `public`     | остаётся `public`                | остаётся `protected` | как в базовом          |
| `protected`  | становится `protected`           | остаётся `protected` | скрыто от внешнего мира|
| `private`    | становится `private`             | становится `private` | доступно только внутри |

#### **Разница между `struct` и `class`**
- `struct Derived : Base` → **`public`** наследование по умолчанию.
- `class Derived : Base` → **`private`** наследование по умолчанию.

---

### **9. Виртуальное наследование**

Решает **проблему ромба**: гарантирует, что **общий предок существует в единственном экземпляре**.

```cpp
class A { public: int x; };
class B : virtual public A {};
class C : virtual public A {};
class D : public B, public C {}; // один подобъект A
```

> Виртуальное наследование требует дополнительных накладных расходов (указатели на vbase), но обеспечивает корректность.

---

### **10. Ключевые слова**

#### **`virtual`**
Объявляет **виртуальный метод** — основа полиморфизма:
```cpp
virtual void draw() = 0; // чисто виртуальный
```

#### **`override`**
Явно указывает, что метод **переопределяет** виртуальный из базового класса:
```cpp
void draw() override;
```
→ Защищает от ошибок (если сигнатура не совпадает — ошибка компиляции).

#### **`final`**
Запрещает дальнейшее наследование:
- от класса: `class A final { };`
- от метода: `void f() final;`

---

### **11. Использование**

#### **Порядок вызова конструкторов**
1. Конструкторы **виртуальных баз** (в порядке объявления).
2. Конструкторы **обычных баз** (в порядке в списке наследования).
3. Конструкторы **членов-объектов**.
4. Тело **конструктора наследника**.

#### **Порядок вызова деструкторов**
Обратный:
1. Тело деструктора наследника.
2. Деструкторы членов.
3. Деструкторы баз (в обратном порядке).
4. Деструкторы виртуальных баз.

> **Важно**: деструктор базового класса **должен быть виртуальным**, если класс предназначен для наследования!

#### **Поиск идентификатора при конфликте**
Если два предка имеют метод с одинаковым именем:
```cpp
d.f(); // ошибка: неоднозначность
d.B::f(); // явное уточнение
```

#### **Вызов метода предка**
Даже если метод переопределён:
```cpp
void Derived::f() {
    Base::f(); // вызов версии из Base
}
```

#### **Доступ через объект и через указатель**
- Через **объект**: вызывается **статически связанный** метод (известен на этапе компиляции).
- Через **указатель/ссылку на базовый класс**: если метод `virtual` — вызывается **динамически связанный** (во время выполнения):
  ```cpp
  Base* p = new Derived();
  p->draw(); // вызовет Derived::draw(), если virtual
  ```

---

### **Заключение**

Наследование в C++ — это мощный, но ответственный инструмент. Оно позволяет строить иерархии типов, реализовывать полиморфизм и повторно использовать код. Однако множественное наследование требует осторожности, а правильное использование `virtual`, `override`, `final` и виртуального наследования — залог надёжности и читаемости. Глубокое понимание порядка инициализации, видов наследования и механизма связывания делает программиста профессионалом и гарантирует высокую оценку на экзамене.

---

**«ООП в C++. Полиморфизм»**
---

Полиморфизм — один из трёх китов объектно-ориентированного программирования (наряду с инкапсуляцией и наследованием). Он позволяет **одному интерфейсу** соответствовать **множеству реализаций**, обеспечивая гибкость, расширяемость и повторное использование кода. В C++ полиморфизм реализуется двумя основными способами: **статически** (на этапе компиляции) и **динамически** (во время выполнения). Рассмотрим все аспекты подробно.

---

### **1. Основная идея и принцип полиморфизма**

Слово *полиморфизм* происходит от греческих слов *poly* (много) и *morphē* (форма) — «много форм».  
Идея: **один и тот же вызов может вести к разному поведению в зависимости от типа объекта**.

Пример:
```cpp
Shape* s1 = new Circle();
Shape* s2 = new Rectangle();
s1->draw(); // рисует круг
s2->draw(); // рисует прямоугольник
```
Один интерфейс (`draw()`), два поведения — это и есть полиморфизм.

---

### **2. Основные понятия**

#### **Абстракция**
Абстракция — это выделение **существенных характеристик объекта**, игнорируя детали реализации.  
В C++ абстракция достигается через:
- абстрактные классы (с чисто виртуальными функциями),
- интерфейсы (классы только с виртуальными методами).

#### **Интерфейс**
Интерфейс — это **контракт**, определяющий, какие операции поддерживает объект.  
В C++ интерфейс задаётся через:
- набор виртуальных методов,
- абстрактный базовый класс.

Пример:
```cpp
class Drawable {
public:
    virtual void draw() = 0; // интерфейс
    virtual ~Drawable() = default;
};
```

---

### **3. Реализация полиморфизма**

Полиморфизм в C++ реализуется двумя способами:

- **Статический полиморфизм** — разрешается **на этапе компиляции**.
- **Динамический полиморфизм** — разрешается **во время выполнения**.

---

### **4. Реализация полиморфизма в C++**

#### **Статический полиморфизм**

##### **Перегрузка функций и операторов**
Функции с **одинаковым именем**, но **разными параметрами**:
```cpp
void print(int x);
void print(double x);
void print(const std::string& s);
```
Компилятор выбирает нужную версию **на основе типов аргументов**.

##### **Как достигается полиморфное поведение?**
- Поведение зависит от **типа аргументов**, известного на этапе компиляции.
- Нет накладных расходов во время выполнения.
- Используется в шаблонах, алгоритмах STL.

> ⚠️ Это **не настоящий ООП-полиморфизм**, но часто называется *ад-хок полиморфизмом*.

---

#### **Динамический полиморфизм**

##### **Виртуальные методы и наследование**
Основан на **виртуальных функциях** и **наследовании**:
```cpp
class Animal {
public:
    virtual void speak() { cout << "???" << endl; }
    virtual ~Animal() = default;
};

class Dog : public Animal {
public:
    void speak() override { cout << "Woof!" << endl; }
};
```

##### **Как достигается полиморфное поведение?**
- Через **указатель или ссылку на базовый класс**:
  ```cpp
  Animal* a = new Dog();
  a->speak(); // вызовет Dog::speak() — динамическое связывание
  ```
- Компилятор генерирует **таблицу виртуальных функций (vtable)** для каждого класса с виртуальными методами.
- Объект содержит **указатель на vtable (vptr)**.
- При вызове `a->speak()` программа:
  1. Смотрит на `vptr` объекта,
  2. Находит нужную функцию в `vtable`,
  3. Вызывает её.

##### **Upcast и Downcast**

- **Upcast** (преобразование к базовому классу):
  ```cpp
  Dog d;
  Animal* a = &d; // безопасно, неявно
  ```
  → Основа полиморфизма.

- **Downcast** (преобразование к производному классу):
  ```cpp
  Animal* a = new Dog();
  Dog* d = dynamic_cast<Dog*>(a); // безопасно, если есть виртуальные функции
  ```
  → Требует явного приведения; `dynamic_cast` проверяет тип во время выполнения.

---

### **5. Проблемы реализации полиморфизма в C++**

1. **Накладные расходы**:
   - Каждый объект с виртуальными функциями содержит `vptr` (+8 байт на x64).
   - Вызов виртуальной функции — косвенный (через таблицу), медленнее обычного.

2. **Невозможность применения к шаблонам напрямую**:
   - Шаблоны — статический полиморфизм, виртуальные функции — динамический.
   - Нельзя сделать шаблонный виртуальный метод.

3. **Проблема срезки (slicing)**:
   ```cpp
   void f(Animal a); // передача по значению
   Dog d;
   f(d); // объект "срезается" до Animal — потеря данных!
   ```
   → Всегда передавать полиморфные объекты **по ссылке или указателю**.

4. **Необходимость виртуального деструктора**:
   - Если базовый класс не имеет виртуального деструктора, удаление через `Base*` не вызовет деструктор производного класса → утечка ресурсов.

5. **Сложность отладки**:
   - Динамическое связывание затрудняет анализ потока выполнения без запуска программы.

6. **Ограничения множественного наследования**:
   - При ромбовидном наследовании без `virtual` возникает неоднозначность.

---

### **Заключение**

Полиморфизм в C++ — это мощный механизм, позволяющий писать гибкий, масштабируемый и поддерживаемый код. Статический полиморфизм (перегрузка, шаблоны) обеспечивает эффективность и типобезопасность на этапе компиляции, а динамический (виртуальные функции, наследование) — гибкость во время выполнения. Однако за эту гибкость приходится платить накладными расходами и повышенной сложностью. Грамотное сочетание обоих подходов — признак зрелого программиста и залог высокой оценки на экзамене.

---

**Билет 1. «Программа на языке Go»**
---

Язык Go (Golang) — это компилируемый, статически типизированный язык программирования, разработанный компанией Google. Он сочетает простоту синтаксиса, эффективность выполнения и встроенную поддержку конкурентности. Программа на Go состоит из одного или нескольких файлов с расширением `.go`, организованных в **пакеты**, и может использовать внешние зависимости через систему модулей. Рассмотрим все аспекты подробно.

---

### **1. Исходный код: файлы `.go`**

Файл с расширением `.go` содержит **исходный код программы** на языке Go.

#### **Что находится внутри?**
- Объявления пакета (`package`)
- Импорты (`import`)
- Объявления переменных, констант, функций, типов
- Реализация логики программы

Пример:
```go
package main

import "fmt"

func main() {
    fmt.Println("Hello, world!")
}
```

#### **Зачем используется?**
Файлы `.go` — это основные единицы исходного кода, которые передаются компилятору Go для создания исполняемого файла. Все файлы одного пакета компилируются вместе.

---

### **2. Файлы `go.mod` и `go.work`**

#### **`go.mod`**
Это файл **модуля**, который определяет:
- Имя модуля (например, `module myproject`)
- Версию Go (`go 1.21`)
- Зависимости от других модулей (`require github.com/user/lib v1.2.3`)

Файл создаётся командой:
```bash
go mod init myproject
```

Он включает программу в **режим модулей** (`GO111MODULE=on` по умолчанию в новых версиях).

#### **`go.work`**
Введён в Go 1.18 для поддержки **workspace-режима**. Позволяет локально работать с несколькими модулями одновременно (например, основной проект + библиотека в разработке):
```go
go 1.21

use (
    .
    ../mylib
)
```
Активируется командой `go work init`.

---

### **3. Структура программы**

#### **Точка входа**
Точка входа — это функция `main` в пакете `main`:
```go
package main

func main() {
    // тело программы
}
```
Без этого компилятор не сможет создать исполняемый файл.

#### **Назначение `return` в `main`**
Функция `main` в Go **не имеет возвращаемого значения** (тип `void`), поэтому:
- `return` без значения допустим (для досрочного выхода),
- `return 0` или другие значения — **запрещены**.

Код завершения программы задаётся через `os.Exit(code)`.

---

### **4. Структурные элементы программы**

- **`package ...`** — объявляет принадлежность файла к пакету.
- **Комментарии**:
  - Однострочные: `// комментарий`
  - Многострочные: `/* комментарий */`
- **Идентификаторы** — имена переменных, функций и т.д. (чувствительны к регистру).
- **Точка с запятой** — ставится автоматически компилятором в конце строки (можно не писать явно).
- **Ключевые слова**: `func`, `var`, `const`, `if`, `for`, `package`, `import`, `struct`, `interface`, `go`, `chan` и др.

---

### **5. Подключение стороннего кода: импорт пакетов**

Go использует **пакеты** как основную единицу модульности.

#### **Способы импорта**

1. **Простой импорт**:
   ```go
   import "fmt"
   ```
   Доступ: `fmt.Println(...)`

2. **Импорт с синонимом**:
   ```go
   import f "fmt"
   ```
   Доступ: `f.Println(...)`

3. **Импорт с поддержкой (blank import)**:
   ```go
   import _ "net/http/pprof"
   ```
   Используется, когда нужен **побочный эффект** (например, регистрация обработчика), но не сам пакет.

4. **Импорт с точкой**:
   ```go
   import . "math"
   ```
   Позволяет использовать функции напрямую: `Sin(x)` вместо `math.Sin(x)`.  
   → **Не рекомендуется** (ухудшает читаемость).

#### **Доступ к импортированным сущностям**
Только **экспортируемые** (публичные) идентификаторы доступны извне:
- Имя должно начинаться с **заглавной буквы**: `Println`, `Reader`, `NewServer`.
- Имена с маленькой буквы — приватные для пакета.

---

### **6. Поиск пакета**

#### **Режим без модулей (`GO111MODULE=off`)**
- Go ищет пакеты в директории `$GOPATH/src`.
- Устаревший подход, не рекомендуется.

#### **Режим с модулями (`GO111MODULE=on`)**
- Зависимости хранятся в `$GOPATH/pkg/mod` (кэш).
- Версии фиксируются в `go.mod` и `go.sum`.
- Поддерживается **воспроизводимая сборка**.

#### **Команда `go get`**
Скачивает и добавляет зависимость в `go.mod`:
```bash
go get github.com/gin-gonic/gin@v1.9.1
```

---

### **7. Сборка программы**

#### **Компилятор**
Go использует собственный **нативный компилятор**, входящий в состав инструментария (`gc`).

#### **Отличие от интерпретации**
- Go — **компилируемый язык**: исходный код → машинный код → исполняемый файл.
- Нет этапа интерпретации → высокая производительность.

#### **Этапы сборки**
1. Лексический и синтаксический анализ.
2. Проверка типов.
3. Генерация машинного кода.
4. Линковка в единый бинарник (статически связанный по умолчанию).

#### **Артефакты сборки**
- **Исполняемый файл** — один бинарник, содержащий всю программу и зависимости (обычно без внешних DLL/SO).
- Нет отдельных `.a`/`.so` файлов при обычной сборке (если не собирается библиотека).

---

### **8. Запуск программы**

#### **Процесс запуска без IDE**
Через терминал:
```bash
go run main.go        # компилирует и сразу запускает
go build -o app .     # создаёт исполняемый файл `app`
./app                 # запуск
```

#### **`go run`**
- Компилирует временный бинарник и запускает его.
- Удобно для разработки и тестирования.

#### **`go build`**
- Создаёт постоянный исполняемый файл.
- Можно указать имя (`-o`) и целевую ОС (`GOOS=linux go build`).

---

### **9. Размещение программы в памяти**

#### **Доступная память**
- **32-битная система**: ~4 ГБ виртуального адресного пространства.
- **64-битная система**: теоретически до 2⁶⁴ байт, на практике ограничено ОС (десятки ТБ).

#### **Стек (stack)**
- Используется для **локальных переменных** и **вызовов функций**.
- Каждая горутина (goroutine) получает **небольшой стек** (~2 КБ), который **автоматически растёт** при необходимости.

#### **Куча (heap)**
- Используется для **динамически выделяемых объектов** (например, через `new`, `make`, или при захвате переменных в замыканиях).
- Управление памятью осуществляется **сборщиком мусора (GC)** — программист не вызывает `free`.

> Go скрывает детали управления памятью, но понимание стека и кучи помогает писать эффективный код.

---

### **Заключение**

Программа на языке Go — это простая, но мощная конструкция, основанная на пакетах, модулях и строгой типизации. Благодаря встроенному инструментарию (`go mod`, `go build`, `go run`), эффективному компилятору и автоматическому управлению памятью, Go позволяет быстро создавать надёжные и производительные приложения. Понимание структуры программы, системы импортов и особенностей памяти — ключ к успешной разработке и высокой оценке на экзамене.

---
