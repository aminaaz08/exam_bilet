# exam_bilet

**Билет 1. «Программа на языке C++»**
---
Язык C++ — это компилируемый язык программирования общего назначения, сочетающий низкоуровневые возможности управления ресурсами с высокоуровневыми абстракциями объектно-ориентированного и обобщённого программирования. Программа на C++ состоит из одного или нескольких **исходных файлов** (обычно с расширением `.cpp`) и **заголовочных файлов** (`.h` или `.hpp`). Рассмотрим подробнее все аспекты, связанные с организацией, сборкой и выполнением такой программы.

---

#### **1. Содержимое файлов `.cpp` и `.h`**

- **Заголовочные файлы** (`.h`, `.hpp`) содержат **объявления**:  
  - прототипы функций,  
  - объявления классов,  
  - макросы,  
  - внешние переменные (`extern`),  
  - шаблоны (в том числе функций и классов).  
  Они служат своего рода «интерфейсом» модуля — то, что другие части программы должны знать о данном модуле, чтобы его использовать.

- **Исходные файлы** (`.cpp`) содержат **определения**:  
  - тела функций,  
  - реализации методов классов,  
  - определения глобальных переменных.  
  Это — исполняемая часть кода, которая компилируется в объектный файл.

---

#### **2. Зачем разделять код на `.h` и `.cpp`?**

Разделение на заголовочные и исходные файлы решает несколько важных задач:

- **Повторное использование**: один заголовочный файл может подключаться во множество `.cpp`-файлов, обеспечивая согласованность интерфейса.
- **Компиляция по частям**: при изменении реализации (в `.cpp`) не нужно перекомпилировать все зависимости — только сам файл. Это ускоряет сборку.
- **Сокрытие реализации**: пользователь модуля видит только интерфейс (`.h`), но не детали реализации (`.cpp`).
- **Избежание множественного определения**: если бы всё было в `.cpp`, подключение одного файла в другой привело бы к дублированию определений при линковке.

---

#### **3. Структура программы**

##### **Точка входа**
Точка входа в любую программу на C++ — это функция `main()`. Она вызывается операционной системой при запуске программы. Существует два стандартных варианта её объявления:

```cpp
int main();
int main(int argc, char* argv[]);
```

Первый — без аргументов командной строки, второй — с ними.

##### **Назначение `return` в `main`**
Оператор `return` в функции `main` возвращает **код завершения программы** в операционную систему:
- `return 0;` или `return EXIT_SUCCESS;` — успешное завершение,
- ненулевое значение (например, `return 1;` или `return EXIT_FAILURE;`) — ошибка.

Если `main` не содержит явного `return`, компилятор автоматически добавляет `return 0;`.

---

#### **4. Структурные элементы программы**

- **Директивы препроцессора**: команды, обрабатываемые до компиляции (например, `#include`, `#define`, `#ifdef`).
- **Комментарии**:
  - Однострочные: `// комментарий`
  - Многострочные: `/* комментарий */`
  - Также возможны документирующие комментарии (Doxygen): `///`, `/** ... */`
- **Подключение стороннего кода**: осуществляется с помощью директивы `#include <...>` (для системных заголовков) или `#include "..."` (для пользовательских).

---

#### **5. Проблемы циклического и повторного подключения заголовков**

Если заголовочный файл подключается несколько раз (прямо или косвенно), возникает ошибка **множественного определения**. Если файлы включают друг друга циклически (`A.h → B.h → A.h`), компилятор зацикливается.

**Способы решения**:

- **Include guards** (защитные директивы):
  ```cpp
  #ifndef MY_HEADER_H
  #define MY_HEADER_H
  // содержимое
  #endif
  ```
- **`#pragma once`** — нестандартная, но широко поддерживаемая директива, обеспечивающая однократное включение файла.

Оба подхода предотвращают повторную обработку содержимого заголовка.

---

#### **6. Подключение статических и динамических библиотек**

- **Статические библиотеки** (`.a` в Linux, `.lib` в Windows) — код библиотеки **копируется** в исполняемый файл на этапе линковки. Преимущества: автономность; недостатки: увеличение размера, невозможность обновления без пересборки.
- **Динамические библиотеки** (`.so` в Linux, `.dll` в Windows) — подгружаются **во время выполнения**. Преимущества: экономия памяти, возможность обновления; недостатки: зависимость от наличия библиотеки в системе.

Подключение:
- На этапе компиляции указываются флаги (`-l` для линковки, `-L` для путей).
- В коде используется `#include` для заголовков библиотеки.

---

#### **7. Этапы сборки программы**

Сборка C++-программы проходит в **четыре основных этапа**:

1. **Препроцессинг**: обработка директив (`#include`, `#define` и т.д.). Результат — расширенный исходный код.
2. **Компиляция**: перевод каждого `.cpp`-файла в **объектный файл** (`.o` или `.obj`), содержащий машинный код, но без разрешения внешних ссылок.
3. **Оптимизация**: выполняется компилятором (на этапе компиляции) или линкером (link-time optimization). Может включать инлайнинг, удаление мёртвого кода, переупорядочивание и т.д.
4. **Компоновка (линковка)**: объединение объектных файлов и библиотек в единый исполняемый файл. Линкер разрешает внешние ссылки (например, вызовы функций из других модулей).

**Основные компиляторы C++**:
- **GCC** (GNU Compiler Collection) — открытый, кроссплатформенный.
- **Clang** — современный, с отличными диагностическими сообщениями.
- **MSVC** (Microsoft Visual C++) — стандарт для Windows в экосистеме Microsoft.

---

#### **8. Артефакты сборки**

- **Исполняемый файл** (`.exe` в Windows, без расширения или с `.out` в Unix-системах) — готовая программа, которую можно запустить.
- **Статическая библиотека** — архив объектных файлов (`.a` / `.lib`), подключаемый на этапе линковки.
- **Динамическая библиотека** — отдельный файл (`.so` / `.dll`), загружаемый ОС при запуске или во время выполнения.

---

#### **9. Запуск программы**

- **Без IDE**: через командную строку:  
  ```bash
  ./my_program arg1 arg2
  ```
- **Поиск динамических библиотек**:
  - В Linux: переменная окружения `LD_LIBRARY_PATH`, системные каталоги (`/usr/lib`, `/lib`).
  - В Windows: текущая директория, системные пути (`PATH`), каталог программы.
- **Аргументы командной строки** передаются в `main` через параметры:
  ```cpp
  int main(int argc, char* argv[])
  ```
  где `argc` — количество аргументов (включая имя программы), `argv` — массив строк с аргументами.

---

#### **10. Размещение программы в памяти**

При запуске программа загружается в **виртуальное адресное пространство процесса**, которое делится на сегменты:

- **Текст (code segment)** — машинные инструкции (только для чтения).
- **Данные**:
  - Инициализированные глобальные/статические переменные (`.data`),
  - Неинициализированные (`.bss`).
- **Стек (stack)** — автоматически управляемая область памяти для локальных переменных и вызовов функций. Растёт «вниз». Ограничен по размеру (обычно несколько МБ).
- **Куча (heap)** — динамически выделяемая память (через `new`/`malloc`). Управляется программистом. Может быть ограничена только объёмом виртуальной памяти.

**Доступный объём памяти зависит от разрядности**:
- **32-битная система**: максимум ~4 ГБ виртуального адресного пространства (часто ~2–3 ГБ для пользователя).
- **64-битная система**: теоретически до 2⁶⁴ байт (~16 ЭБ), на практике ограничено ОС (например, Windows использует 48 бит → ~256 ТБ).

---

### **Заключение**

Таким образом, программа на C++ — это сложная система, включающая строгую модульную структуру, многоэтапную сборку и чёткое распределение ресурсов в памяти. Понимание этих механизмов позволяет писать эффективный, надёжный и поддерживаемый код, а также успешно отлаживать и оптимизировать приложения.

---

 **Билет 2. «Переменные и константы в языке C++»**
---

Переменная в языке C++ — это именованная область памяти, предназначенная для хранения данных определённого типа. Константа — это переменная, значение которой **нельзя изменить** после инициализации. В C++ работа с переменными и константами строго регламентирована и включает правила их создания, именования, размещения в памяти, времени жизни и способов доступа. Рассмотрим все аспекты подробно.

---

### **1. Создание переменной**

Создание переменной в C++ происходит в два этапа:
- **Объявление** — сообщает компилятору имя и тип переменной.
- **Определение** — выделяет память под переменную (может совпадать с объявлением).

Пример:
```cpp
int x;          // объявление + определение
extern int y;   // только объявление
```

---

### **2. Идентификатор переменной**

Идентификатор — это имя переменной.

#### **Правила именования**
- Может содержать буквы латинского алфавита (`a–z`, `A–Z`), цифры (`0–9`) и символ подчёркивания (`_`).
- **Не может начинаться с цифры**.
- **Не может совпадать с ключевыми словами** (`int`, `return`, `class` и т.д.).
- Рекомендуется использовать осмысленные имена (`counter`, `userName`).

#### **Регистр**
- C++ **чувствителен к регистру**: `count`, `Count`, `COUNT` — разные идентификаторы.

---

### **3. Объявление переменной**

Структура объявления:
```cpp
[спецификаторы] тип имя [= инициализатор];
```

Примеры:
```cpp
int a;
double price = 199.99;
const char* name = "Alice";
```

Объявление может включать:
- спецификаторы (`const`, `static`, `extern`, `mutable`),
- тип (`int`, `MyClass`, `auto`),
- инициализатор (опционально).

---

### **4. Ключевые слова**

#### **`const`**
Указывает, что значение переменной **не может быть изменено** после инициализации:
```cpp
const int MAX = 100;
```

#### **`constexpr`**
Гарантирует, что значение вычисляется **на этапе компиляции**:
```cpp
constexpr int square(int x) { return x * x; }
constexpr int val = square(5); // 25 — известно на этапе компиляции
```

#### **`auto`**
Позволяет компилятору **вывести тип** из инициализатора:
```cpp
auto x = 42;        // int
auto y = 3.14;      // double
```

#### **`decltype`**
Возвращает **тип выражения**:
```cpp
int a = 5;
decltype(a) b = 10; // b имеет тип int
```

#### **`extern`**
Указывает, что переменная **определена в другом файле** (объявление без выделения памяти):
```cpp
// file1.cpp
int global_var = 42;

// file2.cpp
extern int global_var; // используем, но не определяем здесь
```

#### **`static`**
- **Для глобальной переменной**: ограничивает видимость текущим файлом (внутреннее связывание).
- **Для локальной переменной**: сохраняет значение между вызовами функции; инициализируется один раз.

```cpp
void func() {
    static int count = 0; // живёт всё время программы
    ++count;
}
```

#### **`mutable`**
Позволяет изменять член класса даже внутри `const`-метода:
```cpp
class Counter {
    mutable int cache;
public:
    void update() const { cache = 42; } // допустимо благодаря mutable
};
```

---

### **5. Определение и ODR**

#### **One Definition Rule (ODR)**
Правило гласит: **любая переменная, функция или класс может иметь ровно одно определение в программе** (если используется). Нарушение → ошибка линковки.

#### **Отличие объявления от определения**
- **Объявление** — сообщает компилятору о существовании сущности (без выделения памяти).
- **Определение** — выделяет память и, возможно, инициализирует.

Пример:
```cpp
extern int x; // объявление
int x = 10;   // определение
```

---

### **6. Инициализация**

#### **Неинициализированные переменные**
- **Локальные** (в функции): содержат **мусор** (неопределённое значение).
- **Глобальные/статические**: автоматически инициализируются **нулем** (zero-initialization).

#### **Значения по умолчанию**
- **Простые типы** (`int`, `double`, указатели):  
  - глобальные → `0`, `0.0`, `nullptr`  
  - локальные → неопределённые  
- **Объекты классов**: вызывается **конструктор по умолчанию**, если он существует.

#### **Способы инициализации (≥3)**
1. **Копирующая инициализация**: `int a = 5;`
2. **Прямая инициализация**: `int a(5);`
3. **Униформная (списочная) инициализация** (C++11): `int a{5};` или `int a = {5};`
4. **Инициализация через `auto`**: `auto x = 10;`
5. **Агрегатная инициализация** (для структур/массивов): `Point p{1, 2};`

#### **Назначение инициализации**
- Гарантирует предсказуемое начальное состояние.
- Предотвращает ошибки, связанные с использованием мусора.

#### **Когда можно не инициализировать?**
- Если переменная будет **гарантированно проинициализирована до первого использования** (например, в `if-else`).
- Однако **лучшая практика — всегда инициализировать**.

---

### **7. Способы выделения памяти**

#### **Стек**
- Автоматическая память.
- Создаётся при входе в блок, уничтожается при выходе.
- Пример:
  ```cpp
  void func() {
      int x = 10; // на стеке
  }
  ```

#### **Куча**
- Динамическая память.
- Выделяется вручную через `new`, освобождается через `delete`.
- Пример:
  ```cpp
  int* p = new int(42); // в куче
  delete p;             // обязательно освободить!
  ```
  В современном C++ рекомендуется использовать **умные указатели** (`std::unique_ptr`, `std::shared_ptr`).

---

### **8. Использование переменной**

Доступ к переменной осуществляется:
- По **имени** (если в области видимости).
- Через **указатель**: `*ptr`
- Через **ссылку**: `ref`

Пример:
```cpp
int x = 5;
int& r = x;     // ссылка
int* p = &x;    // указатель
```

---

### **9. Связывание и область видимости**

#### **Статическое (лексическое) связывание**
- Имя переменной связывается с адресом **на этапе компиляции**.
- Это стандартный механизм в C++.

#### **Динамическое связывание**
- В C++ **не применяется к переменным** (только к виртуальным функциям).
- Переменные всегда связываются статически.

#### **Если переменная определена в другом `.cpp` файле**
- Используется `extern` для объявления.
- Линкер связывает ссылки на этапе сборки.

#### **Область видимости (scope)**
- **Локальная**: внутри блока `{}`.
- **Глобальная**: вне всех функций.
- **Пространство имён**: `namespace N { int x; }`
- **Классовая**: члены класса.

---

### **10. Время жизни и уничтожение**

#### **Автоматические переменные (на стеке)**
- Живут **до конца блока**, в котором объявлены.
- Уничтожаются **автоматически** (деструктор вызывается, если есть).

#### **Динамические переменные (в куче)**
- Живут **до явного вызова `delete`**.
- Если не удалить — **утечка памяти**.

#### **Значение после уничтожения**
- После уничтожения переменной её память **освобождается**.
- Доступ к ней (через «висячий» указатель) — **неопределённое поведение (UB)**.
- Значение **недействительно**, даже если байты ещё не перезаписаны.

---

### **Заключение**

Таким образом, переменные и константы в C++ — это фундаментальные элементы управления данными, требующие глубокого понимания их жизненного цикла, размещения в памяти, правил именования и инициализации. Современный C++ предоставляет мощные инструменты (`const`, `constexpr`, `auto`, умные указатели), позволяющие писать безопасный, эффективный и читаемый код. Владение этими концепциями критически важно для успешной разработки и сдачи экзаменов.

---

 **Билет 3. «Типы данных в языке C++»**
---

Тип данных в языке C++ — это характеристика, определяющая:
- возможные значения переменной,
- операции, которые можно над ней выполнять,
- объём занимаемой памяти,
- способ представления в памяти.

Типизация в C++ **строгая и статическая**: тип переменной проверяется на этапе компиляции и не может меняться во время выполнения. Это обеспечивает безопасность, эффективность и предсказуемость программы.

---

### **1. Зачем нужны типы?**

Типы необходимы по нескольким причинам:
- **Безопасность**: компилятор проверяет корректность операций (нельзя сложить строку с указателем без явного преобразования).
- **Эффективность**: компилятор знает, сколько памяти выделить и как интерпретировать биты.
- **Абстракция**: типы позволяют моделировать реальные объекты (например, `Student`, `Matrix`).
- **Оптимизация**: знание типа позволяет генерировать эффективный машинный код.

---

### **2. Простые (встроенные) типы данных**

#### **Целые числа (`int`, `short`, `long`, `long long`, с модификаторами `signed`/`unsigned`)**

- **Объявление**:
  ```cpp
  int age = 20;
  unsigned short count = 1000;
  ```

- **Допустимые значения (примеры)**:
  - `int`: от −2 147 483 648 до +2 147 483 647 (на 32-битных системах)
  - `unsigned int`: от 0 до 4 294 967 295
  - `char`: от −128 до 127 (`signed char`) или 0–255 (`unsigned char`)

- **Допустимые операторы**:
  - Арифметические: `+`, `-`, `*`, `/`, `%`
  - Побитовые: `&`, `|`, `^`, `<<`, `>>`
  - Сравнения: `==`, `!=`, `<`, `>`, `<=`, `>=`
  - Инкремент/декремент: `++`, `--`

#### **Вещественные числа (`float`, `double`, `long double`)**

- Представляют дробные значения с плавающей точкой.
- Пример:
  ```cpp
  double pi = 3.1415926535;
  float price = 19.99f;
  ```
- Поддерживают арифметические операции, но **не поддерживают `%`**.
- Имеют ограниченную точность → возможны ошибки округления.

#### **Булев тип (`bool`)**

- Может принимать два значения: `true` (обычно 1) и `false` (0).
- Используется в условиях и логических выражениях:
  ```cpp
  bool is_valid = (x > 0);
  if (is_valid) { ... }
  ```

#### **Символьный тип (`char`, `wchar_t`, `char16_t`, `char32_t`)**

- Хранит один символ (в кодировке, зависящей от платформы).
- Пример:
  ```cpp
  char letter = 'A';
  wchar_t wide_char = L'Ω';
  ```
- Фактически — целое число, поэтому допустимы арифметические операции:
  ```cpp
  char next = letter + 1; // 'B'
  ```

---

### **3. Строки**

C++ поддерживает два основных подхода к строкам:

- **C-стиль**: массив символов, завершённый нулём (`'\0'`):
  ```cpp
  char name[] = "Alice";
  ```
- **C++-стиль**: класс `std::string` из стандартной библиотеки:
  ```cpp
  #include <string>
  std::string name = "Alice";
  ```
  Преимущества `std::string`: автоматическое управление памятью, безопасность, богатый интерфейс (`size()`, `substr()`, `+` для конкатенации).

---

### **4. Указатели (без углубления)**

Указатель — это переменная, хранящая **адрес другой переменной**.

- Объявление:
  ```cpp
  int x = 10;
  int* ptr = &x; // ptr хранит адрес x
  ```
- Операции: разыменование (`*ptr`), получение адреса (`&x`).
- Указатели могут быть `nullptr` (нулевой указатель).
- Тип указателя определяет, как интерпретировать данные по адресу.

---

### **5. Ссылки**

Ссылка — это **псевдоним** для существующей переменной.

- **lvalue-ссылки** (обычные):
  ```cpp
  int x = 5;
  int& ref = x; // ref — другое имя для x
  ref = 10;     // x теперь 10
  ```
- Ссылка **должна быть инициализирована** при объявлении.
- Не может быть «нулевой».
- Часто используется в параметрах функций для передачи по ссылке (без копирования).

*(rvalue-ссылки (`T&&`) в рамках билета не требуются, так как указано «без углубления»)*

---

### **6. Составные типы данных**

#### **Массивы**

- **Одномерные**:
  ```cpp
  int arr[5] = {1, 2, 3, 4, 5};
  ```
  Фиксированный размер, размещаются на стеке (если не `new`).

- **Многомерные**:
  ```cpp
  int matrix[3][3]; // матрица 3×3
  ```
  Реализованы как массивы массивов.

> ⚠️ В современном C++ рекомендуется использовать `std::array` (фиксированный размер) или `std::vector` (динамический).

#### **Перечисления**

- **Обычный `enum`**:
  ```cpp
  enum Color { Red, Green, Blue };
  ```
  Значения неявно преобразуются к `int`.

- **`enum class` (scoped enum)** — безопаснее:
  ```cpp
  enum class Status { Ok, Error };
  Status s = Status::Ok; // нельзя неявно привести к int
  ```

#### **Структуры (`struct`)**

Группируют данные разных типов:
```cpp
struct Point {
    double x, y;
};
Point p{1.0, 2.0};
```
По умолчанию — все поля `public`.

#### **Объединения (`union`)**

Хранят **только одно** из полей в один момент времени (все поля используют одну и ту же память):
```cpp
union Data {
    int i;
    float f;
};
```
Используются редко, в основном для низкоуровневых задач.

#### **Классы (`class`)**

Основа объектно-ориентированного программирования:
- Инкапсуляция, наследование, полиморфизм.
- По умолчанию — все поля `private`.
- Могут содержать данные и методы.

Пример:
```cpp
class Rectangle {
private:
    double width, height;
public:
    double area() const { return width * height; }
};
```

---

### **7. Неполные типы**

#### **Какие типы могут быть неполными?**
- Классы, структуры, объединения, перечисления — **до их определения**.
- Также: `void` (неполный, но особый).

Пример:
```cpp
class MyClass; // неполное объявление (forward declaration)
```

#### **Зачем нужны?**
- Для объявления указателей или ссылок без полного определения.
- Для разрешения взаимных зависимостей между классами.
- Для ускорения компиляции (не нужно включать заголовок целиком).

#### **Как использовать?**
- Можно объявлять указатели и ссылки:
  ```cpp
  MyClass* ptr; // OK
  ```
- **Нельзя**: создавать объекты, вызывать методы, получать размер (`sizeof`).

Полное определение должно быть доступно **до первого использования**, требующего знания структуры типа.

---

### **8. Преобразование типов**

#### **Неявное (автоматическое)**
Происходит без участия программиста:
```cpp
int a = 5;
double b = a; // int → double (без потерь)
```
Может приводить к **сужающим преобразованиям** (с потерей данных) — компилятор может выдать предупреждение.

#### **Явное**
Программист чётко указывает преобразование.

##### **В стиле C** (не рекомендуется в C++)
```cpp
int x = (int)3.14;
int y = int(3.14);
```
Опасно: обходит систему типов.

##### **В стиле C++ (операторы приведения)**

- **`static_cast`** — безопасные преобразования внутри иерархии типов:
  ```cpp
  double d = 3.14;
  int i = static_cast<int>(d);
  ```

- **`dynamic_cast`** — безопасное приведение вниз по иерархии наследования (требует виртуальных функций):
  ```cpp
  Base* b = new Derived();
  Derived* d = dynamic_cast<Derived*>(b);
  ```

- **`const_cast`** — добавление/удаление `const`:
  ```cpp
  const int x = 5;
  int* p = const_cast<int*>(&x); // осторожно!
  ```

- **`reinterpret_cast`** — низкоуровневое, опасное преобразование (битовое reinterpretation):
  ```cpp
  int* p = reinterpret_cast<int*>(some_ptr);
  ```
  Используется крайне редко (системное программирование).

---

### **Заключение**

Типы данных в C++ образуют иерархическую систему — от простых встроенных (`int`, `double`) до сложных пользовательских (`class`, `struct`). Понимание их свойств, особенностей и правил преобразования позволяет писать эффективный, безопасный и поддерживаемый код. Современный C++ активно использует строгую типизацию, составные типы и безопасные механизмы приведения, что делает язык мощным инструментом как для системного, так и для прикладного программирования.

---


